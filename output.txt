.
├── app.log
├── app.yaml
├── check.py
├── environment_check.py
├── env.template
├── evaluator.py
├── exercises
│   ├── allejs.txt
│   ├── ApilamientodeCajas.txt
│   ├── Astrovoid.txt
│   ├── Billetes.txt
│   ├── CacheOffline.txt
│   ├── CuadradoMagico.txt
│   ├── DivisiondeCursos.txt
│   ├── exercises_bkp.csv
│   ├── exercises.csv
│   ├── IntercalarOperaciones.txt
│   ├── LanzamientodeDados.txt
│   ├── MaximizarMex.txt
│   ├── MaximoValordeSubconjuntodeTamanok.txt
│   ├── OptimizacióndeTrayectoriasconRestricciones.txt
│   ├── ParejasdeBaile_bmarkEvaluador.txt
│   ├── ParejasdeBaile.txt
│   ├── placeholder.txt
│   ├── Placeholder.txt
│   ├── ProblemadelaFiesta.txt
│   ├── RodCutting.txt
│   ├── SelecciondeActividades.txt
│   ├── SubconjuntosyPermutaciones.txt
│   ├── SumadeElementosconCostoMínimo.txt
│   ├── SumadeSubconjuntos_bmarkEvaluador.txt
│   ├── SumadeSubconjuntos_bmarkFeedback.txt
│   ├── SumadeSubconjuntosPD.txt
│   ├── SumadeSubconjuntos.txt
│   ├── TerrenodeTrampas.txt
│   ├── test.txt
│   └── ViajedeTomas.txt
├── flask_session
│   ├── 054f910b7a32ad6f881dd18c76ac83b5
│   ├── 1ba00dc3e296f73438e92647057f5000
│   ├── 2029240f6d1128be89ddc32729463129
│   ├── 397f4b60129bb512ec25e4b422c3c426
│   ├── 54c4da2ca90f23f6e5937c9ee02810f1
│   ├── 670d70284fbbf78dff31a3a2f9f93704
│   ├── 904dc34402a9ff2ccab87eb4de7a7589
│   ├── 90f11e72200e74545cd367014e1cd37d
│   ├── e9135e07c7140886ee13edf741aba688
│   ├── eb54612c9f2ec2de10ef9c443dfad48d
│   └── fa48a06f80c41e51ef0dd6b877bb8640
├── interactions.json
├── main_bkp.py
├── main.py
├── output.txt
├── privacy_policy.txt
├── __pycache__
│   ├── database.cpython-311.pyc
│   ├── evaluator.cpython-311.pyc
│   ├── exercise.cpython-311.pyc
│   ├── main.cpython-311.pyc
│   └── main.cpython-39.pyc
├── readme.md
├── requirements.txt
├── spreadsheetapp
├── static
│   └── css
│       └── style.css
├── templates
│   ├── exercise.html
│   ├── feedback.html
│   ├── index.html
│   └── login.html
├── terminos-de-servicio.txt
├── testConnection.py
└── tests
    ├── __pycache__
    │   └── test_app.cpython-311-pytest-8.0.1.pyc
    └── test_app.py

8 directories, 69 files
./output.txt
./main_bkp.py
'''
This is the main file of the educational platform.
'''

from flask import Flask, render_template, request, redirect, session, url_for, jsonify
from authlib.integrations.flask_client import OAuth
from flask_session import Session
import os
import requests
from dotenv import load_dotenv
from evaluator import Evaluator
import json
import pandas as pd
import markdown
from google.cloud import logging as cloud_logging
# from flask import Flask, current_app

def configure_cloud_logging(app: Flask):
    if app.config['ENV'] == 'production':  # Asume producción si quieres usar Cloud Logging solo en producción
        client = cloud_logging.Client()
        # Configura Cloud Logging con el entorno de ejecución de Python
        client.setup_logging()

load_dotenv()


# Environment configuration should be done outside of create_app for global access
GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")
GOOGLE_DISCOVERY_URL = "https://accounts.google.com/.well-known/openid-configuration"

def get_google_provider_cfg():
    """Fetches Google's OpenID configuration."""
    return requests.get(GOOGLE_DISCOVERY_URL).json()


def create_app():
    app = Flask(__name__)

    # Configure session
    app.config["SESSION_PERMANENT"] = False
    app.config["SESSION_TYPE"] = "filesystem"
    # Configure Flask to use /tmp for session files
    app.config['SESSION_FILE_DIR'] = '/tmp/flask_session'
    # app.config["SESSION_FILE_DIR"] = "/tmp/flask_session_files"
    app.config['ENV'] = 'development'  # O 'production', según corresponda

    Session(app)
    app.secret_key = os.getenv('SECRET_KEY', 'your_secret_key')

    # Setup OAuth2 client
    oauth = OAuth(app)
    oauth.register(
        name='google',
        client_id=GOOGLE_CLIENT_ID,
        client_secret=GOOGLE_CLIENT_SECRET,
        access_token_url='https://accounts.google.com/o/oauth2/token',
        authorize_url='https://accounts.google.com/o/oauth2/auth',
        api_base_url='https://www.googleapis.com/oauth2/v1/',
        client_kwargs={'scope': 'openid profile email'},
    )# Scope of Access: The request is asking for specific scopes (openid, https://www.googleapis.com/auth/userinfo.email, https://www.googleapis.com/auth/userinfo.profile). Ensure that these scopes are correctly configured and that the application has permission to request them. Also, the user needs to consent to these scopes; if they haven't, it might result in access being denied.




    @app.route("/login")
    def login():
        """Redirect to Google's OAuth2 login page."""
        # Assuming `oauth.google` is correctly configured elsewhere in your application
        redirect_uri = url_for('callback', _external=True)
        return oauth.google.authorize_redirect(redirect_uri=redirect_uri, scope="openid email profile")




    # @app.route("/login")
    # def login():
    #     """Redirect to Google's OAuth2 login page."""
    #     google_provider_cfg = get_google_provider_cfg()
    #     print(f"Google Provider Config: {google_provider_cfg}")
    #     authorization_endpoint = google_provider_cfg["authorization_endpoint"]
    #     print(f"Authorization Endpoint: {authorization_endpoint}")

    #     request_uri = oauth.google.authorize_redirect(
    #         redirect_uri=url_for('callback', _external=True),
    #         scope="openid email profile"
    #     )
    #     print(f"Redirecting to: {request_uri}")  # Debugging line
    #     return redirect(request_uri)

    # @app.route("/login")
    # def login():
    #     """Redirect to Google's OAuth2 login page."""
    #     google_provider_cfg = get_google_provider_cfg()
    #     authorization_endpoint = google_provider_cfg["authorization_endpoint"]
    #     request_uri = oauth.google.authorize_redirect(
    #         redirect_uri=url_for('callback', _external=True),
    #         # scope=["openid", "email", "profile"]
    #         scope="openid email profile"
    #     )
    #     return redirect(request_uri)
    


    # @app.route("/login")
    # def login():
    #     """Redirect to Google's OAuth2 login page."""
    #     google_provider_cfg = get_google_provider_cfg()
    #     authorization_endpoint = google_provider_cfg["authorization_endpoint"]
    #     # request_uri = oauth.google.authorize_redirect(redirect_uri=url_for('callback', _external=True))
    #         # scopes that let you retrieve user's profile from Google
    #     request_uri = google_client.prepare_request_uri(
    #         authorization_endpoint,
    #         redirect_uri=request.base_url + "/callback",
    #         scope=["openid", "email", "profile"],
    #     )
    #     return redirect(request_uri)
    
    # Define all routes here
    @app.route("/")
    def index():
        # Check if user is authenticated
        if 'user' in session:
            # User is logged in
            return render_template('index.html', user=session['user'])
        else:
            # User is not logged in, show login link
            return render_template('login.html')
        # email = dict(session).get('email', None)
        # return f'Hello, {email}!' if email else redirect(url_for('login'))



    # Add more route definitions here
    # # Define routes here or import them if they're defined in other files

    from oauthlib.oauth2 import WebApplicationClient  # For Google authentication
    google_client = WebApplicationClient(GOOGLE_CLIENT_ID)  # You need to set your Google Client ID here

    @app.route("/login/callback")
    def callback():
        # Get authorization code Google sent back to you
        code = request.args.get("code")

        # Find out what URL to hit to get tokens that allow you to ask for
        # things on behalf of a user
        google_provider_cfg = get_google_provider_cfg()
        token_endpoint = google_provider_cfg["token_endpoint"]

        token_url, headers, body = google_client.prepare_token_request(
            token_endpoint,
            authorization_response=request.url,
            redirect_url=request.base_url,
            code=code
        )
        token_response = requests.post(
            token_url,
            headers=headers,
            data=body,
            auth=(GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET),
        )

        # Parse the tokens!
        google_client.parse_request_body_response(json.dumps(token_response.json()))

        # Now that you have tokens (yay) let's find and hit the URL
        # from Google that gives you the user's profile information,
        # including their Google profile image and email
        userinfo_endpoint = google_provider_cfg["userinfo_endpoint"]
        uri, headers, body = google_client.add_token(userinfo_endpoint)
        userinfo_response = requests.get(uri, headers=headers, data=body)

        # You want to make sure their email is verified.
        # The user authenticated with Google, authorized your
        # app, and now you've verified their email through Google!
        if userinfo_response.json().get("email_verified"):
            unique_id = userinfo_response.json()["sub"]
            users_email = userinfo_response.json()["email"]
            picture = userinfo_response.json()["picture"]
            users_name = userinfo_response.json()["given_name"]

            
            # Check if user exists, if not, create new user in our 'database'
            user = User.get(unique_id)
            if not user:
                User.create(unique_id, users_name, users_email, picture)
                user = User.get(unique_id)
            
            # Begin user session
            session['user'] = user.__dict__

            # Redirect to the homepage or dashboard
            return redirect(url_for("index"))
        

        else:
            return "User email not available or not verified by Google.", 400

    ## EXERCISES ROUTES
        
    @app.route('/get_exercises')
    def get_exercises():
        df = pd.read_csv('./exercises/exercises.csv')
        return jsonify(df.to_dict(orient='records'))

    def preprocess_latex_for_mathjax(latex_content):
        # Simple replacement; for demonstration purposes only
        # A robust solution would require actual LaTeX parsing
        latex_content = latex_content.replace(r'\begin{enumerate}', '<ol>')
        latex_content = latex_content.replace(r'\end{enumerate}', '</ol>')
        latex_content = latex_content.replace(r'\item', '<li>')
        # Close the list item
        latex_content = latex_content.replace(r'</li><li>', '</li>\n<li>')
        latex_content = latex_content.replace(r'\begin{center}', '<div style="text-align: center;">').replace(r'\end{center}', '</div>')
        return latex_content

    def get_exercise_content(filename):
        # Assuming your exercise text files are stored in a directory named 'exercises'
        exercises_dir = 'exercises'
        filepath = os.path.join(exercises_dir, filename)
        try:
            with open(filepath, 'r', encoding='utf-8') as file:
                content = file.read()
                # Optional: Wrap LaTeX content in delimiters here if necessary
                content = preprocess_latex_for_mathjax(content)
                return content
        except FileNotFoundError:
            return "Exercise content not found."
        

    def get_exercise_id_from_filename(filename):
        # Extract the exercise ID from the filename
        df = pd.read_csv('exercises/exercises.csv')
        id = df.loc[df.file == filename, 'id'].values[0]
        return id

    @app.route('/exercises/<filename>')
    def exercise(filename):
        content = get_exercise_content(filename)
        exercise_id = get_exercise_id_from_filename(filename)
        # Pass the content to your template, possibly also passing additional data needed for rendering
        return render_template('exercise.html', content=content, exercise_id=exercise_id)

    def record_interaction(user_details, exercise_id, response, evaluated_response):
        interaction = {
            "user_id": user_details.get('id_'),
            "user_name": user_details.get('name'),
            "user_email": user_details.get('email'),
            "exercise_id": exercise_id,
            "response": response,
            "evaluated_response": evaluated_response
        }
        # Use the /tmp directory for compatibility with GCP's environment
        interactions_file_path = '/tmp/interactions.json'
        try:
            with open(interactions_file_path, 'r+') as file:
                try:
                    data = json.load(file)
                except json.JSONDecodeError:
                    data = []  # If the file is empty and causing errors
                data.append(interaction)
                file.seek(0)
                file.truncate()  # Clear the file before re-writing
                json.dump(data, file, indent=4)
        except FileNotFoundError:
            with open(interactions_file_path, 'w') as file:
                json.dump([interaction], file, indent=4)
            with open('/interactions.json', 'w') as file:
                json.dump([interaction], file, indent=4)



    @app.route('/submit_answer', methods=['POST'])
    def submit():
        app.logger.info("Current user session data: %s", session.get('user'))

        if 'user' not in session:
            app.logger.info("User not in session, redirecting to login")
            return redirect(url_for('login'))

        user_details = session.get('user')
        if not user_details:
            app.logger.info("User details not found in session, redirecting to index")
            return redirect(url_for('index'))

        exercise_id = request.form.get('exercise_id')
        response = request.form.get('response')
        app.logger.info("Received exercise_id: %s and response.", exercise_id)

        # Fetch the exercise content based on the exercise_id
        exercise_content = get_exercise_content(exercise_id)
        app.logger.info("Fetched exercise content for exercise_id: %s", exercise_id)

        evaluator = Evaluator()
        evaluated_response = evaluator.evaluate(exercise_content, response)
        app.logger.info("Evaluated response.")

        # Convert Markdown to HTML
        evaluated_response_html = markdown.markdown(evaluated_response)
        app.logger.info("Converted Markdown to HTML.")

        # Record the interaction with all details
        record_interaction(user_details, exercise_id, response, evaluated_response)
        app.logger.info("Recorded interaction.")

        # Pass the HTML-formatted response to the template
        app.logger.info("Rendering template with evaluated response.")
        return render_template('feedback.html', evaluated_response=evaluated_response_html, exercise_id=exercise_id)

    
    @app.route('/logout')
    def logout():
        session.clear()  # Clear Flask session
        return redirect(url_for('index'))  # Redirect to the index page

    @app.route('/health')
    def health():
        return jsonify({"status": "up"}), 200
    

    configure_cloud_logging(app)

    app.config.get('ENV', 'production')

    def configure_logging(app: Flask):
        if app.config['ENV'] == 'production':
            # Configuración de Google Cloud Logging
            configure_cloud_logging(app)
        else:
            import logging
            app.logger.setLevel(logging.DEBUG)
            # from logging.handlers import RotatingFileHandler
            # # Configuración local de logs, p.ej. a consola o archivo local
            # '''Configure logging for the application.'''
            # logging.basicConfig(level=logging.INFO)
            # logger = logging.getLogger(__name__)
            # handler = RotatingFileHandler('app.log', maxBytes=10000, backupCount=3)
            # logger.addHandler(handler)
            # return logger


    configure_logging(app)

    return app

if __name__ == "__main__":
    app = create_app()
    app.run(debug=True)

# A simple in-memory 'database' to store user info
users_db = {}

class User:
    def __init__(self, id_, name, email, profile_pic):
        self.id_ = id_
        self.name = name
        self.email = email
        self.profile_pic = profile_pic

    @staticmethod
    def get(user_id):
        if user_id in users_db:
            user_info = users_db[user_id]
            return User(id_=user_id, **user_info)
        return None

    @staticmethod
    def create(id_, name, email, profile_pic):
        users_db[id_] = {"name": name, "email": email, "profile_pic": profile_pic}
./testConnection.py
import os
import pymysql
import csv

## Conecta con cloud SQL proxy
# (base) matias@matias-ThinkPad-T470-W10DG:~$ ./cloud-sql-proxy -instances=evaluar-app:us-central1:my-sql-instance=tcp:3306^C
# (base) matias@matias-ThinkPad-T470-W10DG:~$ ./cloud-sql-proxy --address 0.0.0.0 --port 3306 evaluar-app:us-central1:my-sql-instance


# Initialize connection variable
connection = None

# # For local development only; remove before deploying
# os.environ['DB_HOST'] = '34.42.138.123'
# os.environ['DB_USER'] = 'root'
# os.environ['DB_PASSWORD'] = '1234'
# os.environ['DB_NAME'] = 'interactions'

# # Load environment variables from .env file or your environment configuration
# db_host = os.getenv('DB_HOST')
# db_user = os.getenv('DB_USER')
# db_password = os.getenv('DB_PASSWORD')
# db_name = os.getenv('DB_NAME')

# db_host = 'localhost' # Instead of dynamically fetching from os.environ
db_host = '127.0.0.1'
db_user = 'root'
db_password = '1234'
db_name = 'interactions'

# Initialize connection variable
connection = None

csv_file_path = './exercises/exercises.csv'

# Try connecting to the database
try:
    # Establish a database connection
    connection = pymysql.connect(host=db_host,
                                user=db_user,
                                password=db_password,
                                db=db_name,
                                local_infile=1,
                                cursorclass=pymysql.cursors.DictCursor)
    
    # cursor = connection.cursor()

    with connection.cursor() as cursor:
        # Create a new table
        create_table_query = """
        CREATE TABLE IF NOT EXISTS exercises (
            id INT AUTO_INCREMENT PRIMARY KEY,
            unit VARCHAR(255),
            name VARCHAR(255),
            info TEXT,
            file TEXT
        )
        """
        cursor.execute(create_table_query)

        
        # Open the CSV file and load the content
        with open(csv_file_path, newline='', encoding='utf-8') as csvfile:
            reader = csv.reader(csvfile)
            next(reader)  # Skip the header row
            
            for row in reader:
                cursor.execute(
                    "INSERT INTO exercises (unit, name, info, file) VALUES (%s, %s, %s, %s)",
                    (*row,)  # Unpack the row list as separate arguments
                    # row
                )
        connection.commit()

    print("Successfully connected to the database.")
except pymysql.MySQLError as e:
    print(f"Failed to connect to the database: {e}")
finally:
    if connection:
        connection.close()./main.py
'''
This is the main file of the educational platform.
'''

from flask import Flask, render_template, request, redirect, session, url_for, jsonify
from authlib.integrations.flask_client import OAuth
from flask_session import Session
import os
import requests
from dotenv import load_dotenv
# from evaluator import Evaluator
from evaluator import Evaluator35, Evaluator40
import json
import logging
from logging.handlers import RotatingFileHandler
import pandas as pd
import markdown

load_dotenv()

# Environment configuration should be done outside of create_app for global access
GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")
GOOGLE_DISCOVERY_URL = "https://accounts.google.com/.well-known/openid-configuration"

def get_google_provider_cfg():
    """Fetches Google's OpenID configuration."""
    return requests.get(GOOGLE_DISCOVERY_URL).json()


def create_app():
    app = Flask(__name__)

    # Configure session
    app.config["SESSION_PERMANENT"] = False
    app.config["SESSION_TYPE"] = "filesystem"
    # Configure Flask to use /tmp for session files
    app.config['SESSION_FILE_DIR'] = '/tmp/flask_session'
    # app.config["SESSION_FILE_DIR"] = "/tmp/flask_session_files"

    Session(app)
    app.secret_key = os.getenv('SECRET_KEY', 'your_secret_key')

    # Setup OAuth2 client
    oauth = OAuth(app)
    oauth.register(
        name='google',
        client_id=GOOGLE_CLIENT_ID,
        client_secret=GOOGLE_CLIENT_SECRET,
        access_token_url='https://accounts.google.com/o/oauth2/token',
        authorize_url='https://accounts.google.com/o/oauth2/auth',
        api_base_url='https://www.googleapis.com/oauth2/v1/',
        client_kwargs={'scope': 'openid profile email'},
    )# Scope of Access: The request is asking for specific scopes (openid, https://www.googleapis.com/auth/userinfo.email, https://www.googleapis.com/auth/userinfo.profile). Ensure that these scopes are correctly configured and that the application has permission to request them. Also, the user needs to consent to these scopes; if they haven't, it might result in access being denied.




    @app.route("/login")
    def login():
        """Redirect to Google's OAuth2 login page."""
        # Assuming `oauth.google` is correctly configured elsewhere in your application
        redirect_uri = url_for('callback', _external=True)
        return oauth.google.authorize_redirect(redirect_uri=redirect_uri, scope="openid email profile")

    # @app.route("/login")
    # def login():
    #     """Redirect to Google's OAuth2 login page."""
    #     google_provider_cfg = get_google_provider_cfg()
    #     print(f"Google Provider Config: {google_provider_cfg}")
    #     authorization_endpoint = google_provider_cfg["authorization_endpoint"]
    #     print(f"Authorization Endpoint: {authorization_endpoint}")

    #     request_uri = oauth.google.authorize_redirect(
    #         redirect_uri=url_for('callback', _external=True),
    #         scope="openid email profile"
    #     )
    #     print(f"Redirecting to: {request_uri}")  # Debugging line
    #     return redirect(request_uri)

    # @app.route("/login")
    # def login():
    #     """Redirect to Google's OAuth2 login page."""
    #     google_provider_cfg = get_google_provider_cfg()
    #     authorization_endpoint = google_provider_cfg["authorization_endpoint"]
    #     request_uri = oauth.google.authorize_redirect(
    #         redirect_uri=url_for('callback', _external=True),
    #         # scope=["openid", "email", "profile"]
    #         scope="openid email profile"
    #     )
    #     return redirect(request_uri)
    

    # @app.route("/login")
    # def login():
    #     """Redirect to Google's OAuth2 login page."""
    #     google_provider_cfg = get_google_provider_cfg()
    #     authorization_endpoint = google_provider_cfg["authorization_endpoint"]
    #     # request_uri = oauth.google.authorize_redirect(redirect_uri=url_for('callback', _external=True))
    #         # scopes that let you retrieve user's profile from Google
    #     request_uri = google_client.prepare_request_uri(
    #         authorization_endpoint,
    #         redirect_uri=request.base_url + "/callback",
    #         scope=["openid", "email", "profile"],
    #     )
    #     return redirect(request_uri)
    
    # Define all routes here
    @app.route("/")
    def index():
        # Check if user is authenticated
        if 'user' in session:
            # User is logged in
            return render_template('index.html', user=session['user'])
        else:
            # User is not logged in, show login link
            return render_template('login.html')
        # email = dict(session).get('email', None)
        # return f'Hello, {email}!' if email else redirect(url_for('login'))

    # Add more route definitions here
    # # Define routes here or import them if they're defined in other files

    from oauthlib.oauth2 import WebApplicationClient  # For Google authentication
    google_client = WebApplicationClient(GOOGLE_CLIENT_ID)  # You need to set your Google Client ID here

    @app.route("/login/callback")
    def callback():
        # Get authorization code Google sent back to you
        code = request.args.get("code")

        # Find out what URL to hit to get tokens that allow you to ask for
        # things on behalf of a user
        google_provider_cfg = get_google_provider_cfg()
        token_endpoint = google_provider_cfg["token_endpoint"]

        token_url, headers, body = google_client.prepare_token_request(
            token_endpoint,
            authorization_response=request.url,
            redirect_url=request.base_url,
            code=code
        )
        token_response = requests.post(
            token_url,
            headers=headers,
            data=body,
            auth=(GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET),
        )

        # Parse the tokens!
        google_client.parse_request_body_response(json.dumps(token_response.json()))

        # Now that you have tokens (yay) let's find and hit the URL
        # from Google that gives you the user's profile information,
        # including their Google profile image and email
        userinfo_endpoint = google_provider_cfg["userinfo_endpoint"]
        uri, headers, body = google_client.add_token(userinfo_endpoint)
        userinfo_response = requests.get(uri, headers=headers, data=body)

        # You want to make sure their email is verified.
        # The user authenticated with Google, authorized your
        # app, and now you've verified their email through Google!
        if userinfo_response.json().get("email_verified"):
            unique_id = userinfo_response.json()["sub"]
            users_email = userinfo_response.json()["email"]
            picture = userinfo_response.json()["picture"]
            users_name = userinfo_response.json()["given_name"]

            
            # Check if user exists, if not, create new user in our 'database'
            user = User.get(unique_id)
            if not user:
                User.create(unique_id, users_name, users_email, picture)
                user = User.get(unique_id)
            
            # Begin user session
            session['user'] = user.__dict__

            # Redirect to the homepage or dashboard
            return redirect(url_for("index"))
        

        else:
            return "User email not available or not verified by Google.", 400

    ## EXERCISES ROUTES
        
    @app.route('/get_exercises')
    def get_exercises():
        df = pd.read_csv('./exercises/exercises.csv')
        return jsonify(df.to_dict(orient='records'))

    def preprocess_latex_for_mathjax(latex_content):
        # Simple replacement; for demonstration purposes only
        # A robust solution would require actual LaTeX parsing
        latex_content = latex_content.replace(r'\begin{enumerate}', '<ol>')
        latex_content = latex_content.replace(r'\end{enumerate}', '</ol>')
        latex_content = latex_content.replace(r'\item', '<li>')
        # Close the list item
        latex_content = latex_content.replace(r'</li><li>', '</li>\n<li>')
        latex_content = latex_content.replace(r'\begin{center}', '<div style="text-align: center;">').replace(r'\end{center}', '</div>')
        return latex_content

    # def get_exercise_content(filename):
    #     # Assuming your exercise text files are stored in a directory named 'exercises'
    #     exercises_dir = 'exercises'
    #     filepath = os.path.join(exercises_dir, filename)
    #     try:
    #         with open(filepath, 'r', encoding='utf-8') as file:
    #             content = file.read()
    #             # Optional: Wrap LaTeX content in delimiters here if necessary
    #             content = preprocess_latex_for_mathjax(content)
    #             return content
    #     except FileNotFoundError:
    #         return "Exercise content not found."
                

    # @app.route('/exercises/<filename>')
    def get_exercise_content(filename):
        # Asumiendo que tus archivos de texto de ejercicios están almacenados en un directorio llamado 'exercises'
        exercises_dir = 'exercises'
        filepath = os.path.join(exercises_dir, filename)
        logger.info(f"Attempting to open exercise file at path: {filepath}")

        try:
            with open(filepath, 'r', encoding='utf-8') as file:
                content = file.read()
                logger.debug(f"Successfully read content from {filename}")
                # Opcional: Envuelve el contenido LaTeX en delimitadores aquí si es necesario
                content = preprocess_latex_for_mathjax(content)
                return content
        except FileNotFoundError:
            logger.error(f"File {filename} not found in directory {exercises_dir}.")
            return "Exercise content not found."
        except Exception as e:
            logger.error(f"An unexpected error occurred while trying to read {filename}: {e}")
            return "An error occurred while fetching the exercise content."
        
    
    def get_filename_from_exercise_id(exercise_id):
        # Extract the filename from the exercise ID
        df = pd.read_csv('exercises/exercises.csv')
        filename = df.loc[df.id == int(exercise_id), 'file'].values[0]
        return filename

    @app.route('/exercises/<filename>')
    def exercise(filename):
        content = get_exercise_content(filename)
        exercise_id = get_exercise_id_from_filename(filename)
        # Pass the content to your template, possibly also passing additional data needed for rendering
        return render_template('exercise.html', content=content, exercise_id=exercise_id)

    def get_exercise_id_from_filename(filename):
        # Extract the exercise ID from the filename
        df = pd.read_csv('exercises/exercises.csv')
        id = df.loc[df.file == filename, 'id'].values[0]
        return id


    @app.route('/submit_answer', methods=['POST'])
    def submit():
        logger.info("Current user session data: %s", session.get('user'))

        if 'user' not in session:
            logger.info("User not in session, redirecting to login")
            return redirect(url_for('login'))

        user_details = session.get('user')
        if not user_details:
            logger.info("User details not found in session, redirecting to index")
            return redirect(url_for('index'))


        exercise_id = request.form.get('exercise_id')
        response = request.form.get('response')
        logger.info("Received exercise_id: %s and response.", exercise_id)

        # Convert exercise_id to filename
        filename = get_filename_from_exercise_id(exercise_id)

        # Fetch the exercise content based on the filename
        exercise_content = get_exercise_content(filename)
        logger.info("Fetched exercise content for exercise_id: %s", exercise_id)

        # evaluator = Evaluator()
        # evaluated_response = evaluator.evaluate(exercise_content, response)
        # logger.info("Evaluated response.")

        # Asumiendo que tienes una variable de entorno EVALUATOR_MODEL que puede ser "gpt-3.5" o "gpt-4"
        model = os.getenv("EVALUATOR_MODEL", "gpt-3.5")

        if model == "gpt-3.5":
            evaluator = Evaluator35()
        elif model == "gpt-4":
            evaluator = Evaluator40()
        else:
            raise ValueError(f"Modelo de evaluador no soportado: {model}")

        # logger.info(f"About to call evaluate with exercise_content: '{exercise_content}' and response: '{response}'")
        logger.info(f"About to call evaluate with exercise_content:  and response: '{response}'")
        evaluated_response = evaluator.evaluate(exercise_content, response)
        logger.info("Evaluated response.")

        # Convert Markdown to HTML
        evaluated_response_html = markdown.markdown(evaluated_response)
        logger.info("Converted Markdown to HTML.")

        # Record the interaction with all details
        record_interaction(user_details, exercise_id, response, evaluated_response)
        logger.info("Recorded interaction.")

        # Pass the HTML-formatted response to the template
        logger.info("Rendering template with evaluated response.")
        return render_template('feedback.html', evaluated_response=evaluated_response_html, exercise_id=exercise_id)



    def record_interaction(user_details, exercise_id, response, evaluated_response):
        interaction = {
            "user_id": user_details.get('id_'),
            "user_name": user_details.get('name'),
            "user_email": user_details.get('email'),
            "exercise_id": exercise_id,
            "response": response,
            "evaluated_response": evaluated_response
        }
        # Use the /tmp directory for compatibility with GCP's environment
        interactions_file_path = '/tmp/interactions.json'
        try:
            with open(interactions_file_path, 'r+') as file:
                try:
                    data = json.load(file)
                except json.JSONDecodeError:
                    data = []  # If the file is empty and causing errors
                data.append(interaction)
                file.seek(0)
                file.truncate()  # Clear the file before re-writing
                json.dump(data, file, indent=4)
        except FileNotFoundError:
            with open(interactions_file_path, 'w') as file:
                json.dump([interaction], file, indent=4)
            # with open('/interactions.json', 'w') as file:
            #     json.dump([interaction], file, indent=4)

    
    @app.route('/logout')
    def logout():
        session.clear()  # Clear Flask session
        return redirect(url_for('index'))  # Redirect to the index page

    @app.route('/health')
    def health():
        return jsonify({"status": "up"}), 200

    def configure_logging():
        logging.basicConfig(level=logging.INFO)
        logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
        logger = logging.getLogger(__name__)
        # Additional logger configuration...
        return logger

    # def configure_logging():
    #     '''Configure logging for the application.'''
    #     logging.basicConfig(level=logging.INFO)
    #     # logger = logging.getLogger(__name__)
    #     # handler = RotatingFileHandler('app.log', maxBytes=10000, backupCount=3)
    #     # logger.addHandler(handler)
    #     # return logger

    logger = configure_logging()

    return app

if __name__ == "__main__":
    app = create_app()
    app.run(debug=True)

# A simple in-memory 'database' to store user info
users_db = {}

class User:
    def __init__(self, id_, name, email, profile_pic):
        self.id_ = id_
        self.name = name
        self.email = email
        self.profile_pic = profile_pic

    @staticmethod
    def get(user_id):
        if user_id in users_db:
            user_info = users_db[user_id]
            return User(id_=user_id, **user_info)
        return None

    @staticmethod
    def create(id_, name, email, profile_pic):
        users_db[id_] = {"name": name, "email": email, "profile_pic": profile_pic}
./tests/test_app.py
# tests/test_app.py
import os
import sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import pytest
from main import create_app
from flask import url_for
# Mockresponse
class MockResponse:
    def __init__(self, json_data, status_code):
        self.json_data = json_data
        self.status_code = status_code

    def json(self):
        return self.json_data


@pytest.fixture
def client():
    app = create_app()
    app.config['TESTING'] = True
    with app.test_client() as client:
        yield client

# # Environment configuration should be done outside of create_app for global access
# GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
# GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")
# GOOGLE_DISCOVERY_URL = "https://accounts.google.com/.well-known/openid-configuration"


@pytest.fixture(autouse=True)
def set_env_vars():
    os.environ['GOOGLE_CLIENT_ID'] = os.getenv("GOOGLE_CLIENT_ID")
    os.environ['GOOGLE_CLIENT_SECRET'] = os.getenv("GOOGLE_CLIENT_SECRET")

def test_health(client):
    response = client.get('/health')
    assert response.status_code == 200
    assert response.json == {"status": "up"}


# 1. Test User Authentication Flow
def test_login_redirect(client):
    response = client.get('/login')
    assert response.status_code == 302
    # assert "accounts.google.com" in response.location  # This checks if redirection to Google's OAuth page occurs

def test_callback_handling(client, mocker):
    # Mock `requests.post` to simulate Google's response for token exchange
    mocker.patch('requests.post', return_value=MockResponse({
        'access_token': 'fake_access_token',
        'refresh_token': 'fake_refresh_token',
        'token_type': 'Bearer',
        'expires_in': 3600,
    }, 200))
    
    # Mock `requests.get` to simulate Google's UserInfo response
    mocker.patch('requests.get', return_value=MockResponse({
        'sub': '1234567890',
        'email': 'user@example.com',
        'email_verified': True,
        'name': 'Mock User',
        'picture': 'https://example.com/photo.jpg',
    }, 200))

    # response = client.get('/login/callback?code=fake_auth_code') ## need to fix this

    # assert response.status_code == 302
    # assert url_for('index') in response.location  # This checks if user is redirected to the index page after authentication


# 2. Test Exercise Content Retrieval
def test_get_exercises(client):
    response = client.get('/get_exercises')
    assert response.status_code == 200
    assert isinstance(response.json, list)  # This checks if a list of exercises is returned

def test_view_exercise(client):
    response = client.get('/exercises/TerrenodeTrampas.txt')
    assert response.status_code == 200
    # fix this
    # assert "Exercise content" in response.data.decode('utf-8')  # Replace "Exercise content" with actual expected content


# 3. Test Submission and Feedback
def test_submit_answer(client):
    with client.session_transaction() as sess:
        sess['user'] = {'id_': '123', 'name': 'Test User', 'email': 'test@example.com'}

    response = client.post('/submit_answer', data={'exercise_id': 'sample_exercise', 'response': 'Test answer'})
    assert response.status_code == 200
    # assert "Your feedback" in response.data.decode('utf-8')  # Replace "Your feedback" with actual expected feedback content


# 4. Logout and Session Clearing
def test_logout(client):
    with client.session_transaction() as sess:
        sess['user'] = {'id_': '123', 'name': 'Test User'}

    response = client.get('/logout')
    assert response.status_code == 302
    assert url_for('index') in response.location
    with client.session_transaction() as sess:
        assert 'user' not in sess  # This checks if the session is cleared

./evaluator.py
import os
import openai
from dotenv import load_dotenv
import logging
# Load environment variables from .env file
load_dotenv()

logger = logging.getLogger(__name__)  # Usa el mismo logger configurado globalmente

from abc import ABC, abstractmethod

class Evaluator(ABC):
    def __init__(self, model_name):
        self.model_name = model_name
        openai.api_key = os.getenv('OPENAI_API_KEY')

    @abstractmethod
    def construct_prompt(self, exercise_content, response):
        pass

    @abstractmethod
    def evaluate(self, exercise_content, response):
        pass


class Evaluator35(Evaluator):
    def __init__(self):
        super().__init__(model_name="gpt-3.5-turbo-instruct")


    def construct_prompt(self, exercise_content, response, evaluation_style="neutral"):
        if not exercise_content or not response:
            logger.error("Received invalid exercise_content or response. GPT35")
            # Devuelve un valor predeterminado o maneja el error adecuadamente
            return "Error: El contenido del ejercicio o la respuesta del estudiante no es válido."
        
        # Introduction to the exercise and response for a conversational context
        prompt_introduction = (
            "A continuación, se presenta una respuesta de un estudiante a un ejercicio de ciencias de la computación. "
            "Primero, evalúa brevemente la calidad de la respuesta del estudiante a un ejercicio de ciencias de la computación. "
            "Esta evaluación inicial ayudará a evitar generar feedback extenso e inapropiado para respuestas que no lo ameriten.\n\n"
            "Basándote en criterios académicos de alto nivel y enfocándome en proporcionar un feedback constructivo, "
            "analiza la respuesta, destacando los aspectos positivos y señalando áreas de mejora. "
            "Además, ofrece recomendaciones para profundizar en la comprensión de los conceptos tratados. "
        )
        

        # Incorporating the exercise content and student's response
        exercise_and_response = (
            f"Ejercicio:\n{exercise_content}\n\n"
            f"Respuesta del estudiante:\n{response}\n\n"
        )
        
        # Instructions for AI on how to proceed with the evaluation
        evaluation_instructions = (
            "Evalúa la respuesta siguiendo estas directrices, equilibrando comentarios positivos con áreas de mejora. "
            "Proporciona ejemplos concretos de cómo mejorar el algoritmo o abordar casos especiales y orienta hacia recursos específicos que puedan explorar para reforzar los conceptos discutidos. "
            "Promueve un ambiente de aprendizaje positivo, estimulando la reflexión y la iniciativa por parte del estudiante. Espanol de Argnetina. Sos mujer."
            "Ten mucho cuidado cuando cites libros, hace un doble chequeo de que efectivamente existan. No recomiendes Coursera u otras plataformas de aprendizaje online."
            "No inviertas todos los token en una respuesta larga, si el estudiante no propone una resolucion detallada. Manten la respuesta corta y concisa pero sin olvidar ningun detalle."
        )
        
        # Combining all parts into the final prompt
        complete_prompt = f"{prompt_introduction}{exercise_and_response}{evaluation_instructions}"
        # logger.info(f"Constructed prompt for OpenAI API call. : {complete_prompt}")
        return complete_prompt



    # Si es necesario, sobrescribe otros métodos específicos del modelo

    def evaluate(self, exercise_content, response):
        logger.info(f"Inside Evaluator35")
        # Call to construct the prompt with the exercise content and student's response
        prompt = self.construct_prompt(exercise_content, response)
        # API call to OpenAI
        try:

            # GPT 3.5
            completion = openai.Completion.create(
                engine="gpt-3.5-turbo-instruct",  # Adjust based on the available engines
                # engine="gpt-4-turbo-preview",  # Updated to use a GPT-4 model variant
                prompt=prompt,
                temperature=0.7,
                max_tokens=550,
                n=1,
                stop=None
            )

            # Asegurándote de acceder correctamente a la respuesta
            evaluated_response = completion.choices[0].text.strip() # GPT 3.5
            logger.info("Received evaluation response from OpenAI API.")
            
            return evaluated_response


        except Exception as e:
            logger.error(f"Error calling OpenAI API: {e}")
            return "Error evaluando la respuesta."


class Evaluator40(Evaluator):
    def __init__(self):
        super().__init__(model_name="gpt-4-turbo-preview")


    def construct_prompt(self, exercise_content, response, evaluation_style="neutral"):
        if not exercise_content or not response:
            logger.error("Received invalid exercise_content or response. GPT40")
            # Devuelve un valor predeterminado o maneja el error adecuadamente
            return "Error: El contenido del ejercicio o la respuesta del estudiante no es válido."

        # Construcción específica del prompt para GPT-4
        prompt_introduction = (
            "A continuación, se presenta una respuesta de un estudiante a un ejercicio de ciencias de la computación. "
            "Basándote en criterios académicos de alto nivel y enfocándome en proporcionar un feedback constructivo, "
            "analiza la respuesta, destacando los aspectos positivos y señalando áreas de mejora. "
            "Además, ofrece recomendaciones para profundizar en la comprensión de los conceptos tratados. "
        )
        
        # Incorporating the exercise content and student's response
        exercise_and_response = (
            f"Ejercicio:\n{exercise_content}\n\n"
            f"Respuesta del estudiante:\n{response}\n\n"
        )
        
        # Instructions for AI on how to proceed with the evaluation
        evaluation_instructions = (
            "Evalúa la respuesta siguiendo estas directrices, equilibrando comentarios positivos con áreas de mejora. "
            "Proporciona ejemplos concretos de cómo mejorar el algoritmo o abordar casos especiales y orienta hacia recursos específicos que puedan explorar para reforzar los conceptos discutidos. "
            "Promueve un ambiente de aprendizaje positivo, estimulando la reflexión y la iniciativa por parte del estudiante. Espanol de Argnetina. Sos mujer."
            "Ten mucho cuidado cuando cites libros, hace un doble chequeo de que efectivamente existan. No recomiendes Coursera u otras plataformas de aprendizaje online."
            "No inviertas todos los token en una respuesta larga, si el estudiante no propone una resolucion detallada. Manten la respuesta corta y concisa pero sin olvidar ningun detalle."
        )
        
        # Combining all parts into the final prompt
        complete_prompt = f"{prompt_introduction}{exercise_and_response}{evaluation_instructions}"
        logger.info(f"Constructed prompt for OpenAI API call. : {complete_prompt}")
        return complete_prompt


    # Implementación específica para chat_completion si es diferente

    def evaluate(self, exercise_content, response):
        logger.info(f"Inside Evaluator40")

        # Call to construct the prompt with the exercise content and student's response
        # prompt = self.construct_prompt(exercise_content, response)
        # API call to OpenAI
        try:

            system_instructions = {
                "role": "system",
                "content": "You are an AI tutor evaluating a student's response to a computer science exercise. Provide detailed, constructive feedback focusing on both strengths and areas for improvement. Offer specific examples for enhancing the algorithm or addressing special cases. Recommend resources like readings, tutorials, or online tools for further exploration. Your feedback should incorporate academic and practical considerations in computer science, suitable for advanced students. Provide guidance in Spanish (Argentina) and assume a supportive and encouraging tone to foster a positive learning environment. Aim to stimulate reflection and initiative, including practical and theoretical recommendations to support academic and professional development. Encourage the examination of case studies or practical examples for a deeper, applied understanding of concepts. Suggest additional resources to enrich learning and promote a problem-solving approach."
            }


            chat_completion = openai.ChatCompletion.create(
                model="gpt-4-turbo-preview",
                messages=[
                    system_instructions,
                    {"role": "user", "content": self.construct_prompt(exercise_content, response)}
                ],
                temperature=0.7,
                max_tokens=1100,
                n=1,
                stop=None
            )

            # Asegurándote de acceder correctamente a la respuesta
            evaluated_response = chat_completion.choices[0].message['content'].strip()
            logger.info("Received evaluation response from OpenAI API.")
            
            return evaluated_response

        except Exception as e:
            logger.error(f"Error calling OpenAI API: {e}")
            return "Error evaluando la respuesta."
./interactions.json
[
    {
        "user_id": "101939652595892022773",
        "exercise_id": "",
        "response": "test"
    },
    {
        "user_id": "101939652595892022773",
        "exercise_id": "",
        "response": "test"
    },
    {
        "user_id": "101939652595892022773",
        "exercise_id": "",
        "response": "test"
    },
    {
        "user_id": "101939652595892022773",
        "exercise_id": "",
        "response": "test"
    },
    {
        "user_id": "101939652595892022773",
        "exercise_id": "",
        "response": "test"
    },
    {
        "user_id": "101939652595892022773",
        "exercise_id": "",
        "response": "test"
    },
    {
        "user_id": "101939652595892022773",
        "exercise_id": "",
        "response": "test"
    },
    {
        "user_id": "101939652595892022773",
        "exercise_id": "",
        "response": "test2"
    },
    {
        "user_id": "101939652595892022773",
        "user_name": "Mat\u00edas",
        "user_email": "matuteiglesias@gmail.com",
        "exercise_id": "",
        "response": "test3\r\n",
        "evaluated_response": "I'm sorry, I don't understand what you are asking. Can you please provide more context or information?"
    },
    {
        "user_id": "101939652595892022773",
        "user_name": "Mat\u00edas",
        "user_email": "matuteiglesias@gmail.com",
        "exercise_id": "57",
        "response": "test4. nevermind.",
        "evaluated_response": "This response lacks context and may not be helpful or relevant to the conversation. It would be more effective to provide a clear and concise response or explanation."
    },
    {
        "user_id": "101939652595892022773",
        "user_name": "Mat\u00edas",
        "user_email": "matuteiglesias@gmail.com",
        "exercise_id": "57",
        "response": "respuesta\r\n",
        "evaluated_response": "The response appears to be a Spanish word, meaning \"response\" in English. It is a correct and appropriate translation."
    },
    {
        "user_id": "101939652595892022773",
        "user_name": "Mat\u00edas",
        "user_email": "matuteiglesias@gmail.com",
        "exercise_id": "57",
        "response": "[this is a test placeholder]",
        "evaluated_response": "En esta respuesta, el estudiante no proporciona una soluci\u00f3n al ejercicio. En lugar de eso, simplemente escribe un mensaje de prueba. Como estudiante de maestr\u00eda en ciencias de la computaci\u00f3n, se espera que tenga un buen dominio de los conceptos te\u00f3ricos y la capacidad de aplicarlos en situaciones pr\u00e1cticas.\n\nPara mejorar su respuesta, le recomendar\u00eda que primero lea cuidadosamente el enunciado del ejercicio y se asegure de entender lo que se est\u00e1 pidiendo. A continuaci\u00f3n, puede comenzar a trabajar en una soluci\u00f3n, asegur\u00e1ndose de que sea completa y bien explicada. Aseg\u00farese de incluir todo el c\u00f3digo necesario"
    },
    {
        "user_id": "101939652595892022773",
        "user_name": "Mat\u00edas",
        "user_email": "matuteiglesias@gmail.com",
        "exercise_id": "54",
        "response": "Mmmm estoy un poco confundido... a que se refiere con \"dar una implementacion?\" Como deberia abordar la respuesta?",
        "evaluated_response": "\u00a1Hola!\n\nGracias por tu respuesta. Para dar una implementaci\u00f3n significa escribir un c\u00f3digo que resuelva el problema planteado en el ejercicio. En este caso, se espera que utilices tus conocimientos en ciencias de la computaci\u00f3n para crear un programa que cumpla con los requisitos indicados en el enunciado.\n\nPara abordar la respuesta, te recomiendo seguir los siguientes pasos:\n\n1. Lee detalladamente el enunciado del ejercicio y aseg\u00farate de entender lo que se te pide.\n2. Utiliza tus conocimientos te\u00f3ricos para determinar qu\u00e9 herramientas y t\u00e9cnicas son necesarias para resolver el problema.\n3. Crea un plan de acci\u00f3n, es"
    },
    {
        "user_id": "101939652595892022773",
        "user_name": "Mat\u00edas",
        "user_email": "matuteiglesias@gmail.com",
        "exercise_id": "57",
        "response": "test5",
        "evaluated_response": "Estimado estudiante,\n\nGracias por participar en el ejercicio. Sin embargo, tu respuesta \"test5\" no cumple con las expectativas de conocimiento para un estudiante avanzado en ciencias de la computaci\u00f3n.\n\nPara empezar, es importante siempre leer cuidadosamente el enunciado y asegurarse de entender lo que se est\u00e1 pidiendo antes de responder. En este caso, el contenido del ejercicio no se encontr\u00f3, por lo que no se puede evaluar tu respuesta.\n\nAdem\u00e1s, como estudiante avanzado en ciencias de la computaci\u00f3n, se espera que tengas una comprensi\u00f3n te\u00f3rica s\u00f3lida de los conceptos y que puedas aplicarlos en situaciones pr\u00e1cticas. Tu respuesta no demuestra ninguna de estas habilidades.\n\nMi sugerencia es que vuelvas a revisar tus apuntes y materiales de estudio para asegurarte de tener una comprensi\u00f3n completa de los conceptos relevantes para este ejercicio. Tambi\u00e9n te recomiendo que practiques resolviendo problemas similares o que busques ejemplos pr\u00e1cticos en l\u00ednea para mejorar tu aplicaci\u00f3n pr\u00e1ctica de estos conceptos.\n\nRecuerda que siempre puedes hacer preguntas si no entiendes algo o necesitas m\u00e1s orientaci\u00f3n. Mi objetivo es ayudarte a mejorar y alcanzar tus metas acad\u00e9micas. Espero ver una mejora en tus futuras respuestas.\n\nSigue esforz\u00e1ndote y no te desanimes. Estoy seguro de que con dedicaci\u00f3n y pr\u00e1ctica, podr\u00e1s alcanzar un alto nivel de conocimiento en ciencias de la computaci\u00f3n.\n\nSaludos, \n[Nombre del profesor]"
    },
    {
        "user_id": "123",
        "user_name": "Test User",
        "user_email": "test@example.com",
        "exercise_id": "sample_exercise",
        "response": "Test answer",
        "evaluated_response": "Estimado estudiante,\n\nGracias por tu respuesta. Sin embargo, me gustar\u00eda que pudieras proporcionar una respuesta m\u00e1s detallada y espec\u00edfica al ejercicio. Recuerda que como estudiante avanzado en ciencias de la computaci\u00f3n, se espera que tengas un buen entendimiento te\u00f3rico y que puedas aplicar los conceptos de manera pr\u00e1ctica.\n\nTe sugiero revisar nuevamente el ejercicio y asegurarte de entender completamente su contenido. Tambi\u00e9n puedes buscar recursos adicionales, como libros o tutoriales, para ayudarte a profundizar en los conceptos que se abordan en el ejercicio.\n\nAdem\u00e1s, me gustar\u00eda animarte a que hagas preguntas si hay algo que no entiendes o si necesitas m\u00e1s orientaci\u00f3n. Estoy aqu\u00ed para ayudarte a mejorar tus habilidades en inform\u00e1tica y estoy dispuesto a brindarte la orientaci\u00f3n que necesites.\n\nRecuerda que siempre es importante reflexionar sobre tu trabajo y esforzarte por mejorar constantemente. \u00a1Sigue practicando y estoy seguro de que pronto ver\u00e1s una mejora en tus habilidades en ciencias de la computaci\u00f3n!\n\nSigue adelante con tu trabajo y no dudes en comunicarte conmigo si tienes alguna pregunta o necesitas m\u00e1s ayuda.\n\n\u00a1Mucho \u00e9xito en tus estudios!\n\nSinceramente,\n[Nombre del profesor]"
    },
    {
        "user_id": "123",
        "user_name": "Test User",
        "user_email": "test@example.com",
        "exercise_id": "sample_exercise",
        "response": "Test answer",
        "evaluated_response": "Estimado estudiante,\n\nGracias por tu respuesta al ejercicio. Me alegra ver que est\u00e1s interesado en mejorar y seguir aprendiendo. Sin embargo, me gustar\u00eda darte algunos comentarios para que puedas alcanzar un nivel m\u00e1s avanzado en ciencias de la computaci\u00f3n.\n\nEn primer lugar, me di cuenta de que tu respuesta no est\u00e1 relacionada con el ejercicio propuesto. Recuerda siempre leer cuidadosamente las instrucciones y asegurarte de entender lo que se te pide antes de comenzar a responder. Esto te ayudar\u00e1 a enfocarte en los conceptos correctos y evitar errores.\n\nAdem\u00e1s, me gustar\u00eda ver m\u00e1s evidencia de tu comprensi\u00f3n te\u00f3rica de los conceptos. En ciencias de la computaci\u00f3n, es importante no solo saber c\u00f3mo aplicar una soluci\u00f3n, sino tambi\u00e9n comprender por qu\u00e9 funciona y c\u00f3mo se relaciona con otros conceptos. Te animo a revisar tus notas y material de lectura para fortalecer tu base te\u00f3rica.\n\nPor otro lado, me gustar\u00eda ver una aplicaci\u00f3n pr\u00e1ctica de los conceptos en tu respuesta. Puedes hacerlo explicando c\u00f3mo aplicar\u00edas lo que has aprendido en una situaci\u00f3n o problema real. Esto demuestra que entiendes c\u00f3mo utilizar los conceptos en situaciones pr\u00e1cticas y no solo te\u00f3ricas.\n\nPor \u00faltimo, te aconsejo que siempre hagas preguntas si no entiendes algo o necesitas m\u00e1s orientaci\u00f3n. Como profesor, estoy aqu\u00ed para ayudarte a alcanzar tus metas y estoy m\u00e1s que dispuesto a proporcionar orientaci\u00f3n y explicaciones adicionales si las necesitas.\n\nSigue mostrando inter\u00e9s y esfuerzo en tu aprendizaje y estoy seguro de que alcanzar\u00e1s un nivel avanzado en ciencias de la computaci\u00f3n. \u00a1\u00c1nimo y sigue adelante!\n\nSaludos cordiales,\n\n[Nombre del profesor]"
    },
    {
        "user_id": "123",
        "user_name": "Test User",
        "user_email": "test@example.com",
        "exercise_id": "sample_exercise",
        "response": "Test answer",
        "evaluated_response": "Estimado estudiante,\n\nGracias por tu participaci\u00f3n en este ejercicio. Sin embargo, parece que la respuesta que proporcionaste no se ajusta al contenido del ejercicio. Es importante que leas cuidadosamente las instrucciones y comprendas lo que se te pide antes de responder.\n\nEn cuanto a tus conocimientos en ciencias de la computaci\u00f3n, es importante que puedas aplicar tanto la teor\u00eda como la pr\u00e1ctica de los conceptos. En este caso, te recomiendo que revises el contenido del ejercicio y trates de entender c\u00f3mo aplicar los conceptos que has aprendido en este curso.\n\nPara mejorar, te sugiero que vuelvas a intentar el ejercicio y aseg\u00farate de entender completamente lo que se te pide. Tambi\u00e9n puedes hacer preguntas si hay algo que no comprendes o necesitas m\u00e1s orientaci\u00f3n.\n\nEn general, es importante que te esfuerces por mejorar y reflexionar sobre tus respuestas. Esto te ayudar\u00e1 a desarrollar una mejor comprensi\u00f3n de los conceptos y a tener \u00e9xito en tu carrera en ciencias de la computaci\u00f3n.\n\nSigue adelante y no dudes en contactarme si tienes alguna pregunta o necesitas m\u00e1s orientaci\u00f3n en este o en otros ejercicios.\n\n\u00a1Sigue as\u00ed y no te rindas!\n\nSaludos,\n[Nombre del profesor]"
    },
    {
        "user_id": "123",
        "user_name": "Test User",
        "user_email": "test@example.com",
        "exercise_id": "sample_exercise",
        "response": "Test answer",
        "evaluated_response": "Estimado estudiante,\n\nGracias por tu respuesta al ejercicio, sin embargo, me gustar\u00eda ofrecerte algunas sugerencias para mejorar tu respuesta y alcanzar un nivel m\u00e1s avanzado en ciencias de la computaci\u00f3n.\n\nEn primer lugar, ser\u00eda \u00fatil si proporcionas una respuesta m\u00e1s espec\u00edfica al ejercicio en lugar de simplemente escribir \"test answer\". Aseg\u00farate de leer cuidadosamente el enunciado del ejercicio y proporcionar una respuesta que demuestre tu comprensi\u00f3n del mismo.\n\nAdem\u00e1s, es importante que demuestres una comprensi\u00f3n te\u00f3rica s\u00f3lida en tus respuestas. Ser\u00eda beneficioso si incluyes explicaciones detalladas de los conceptos y teor\u00edas relevantes en lugar de solo escribir una respuesta corta.\n\nPor \u00faltimo, te recomendar\u00eda que apliques los conceptos que has aprendido en la pr\u00e1ctica. Intenta proporcionar ejemplos o aplicaciones pr\u00e1cticas de los conceptos te\u00f3ricos en tus respuestas. Esto no solo demostrar\u00e1 tu comprensi\u00f3n, sino que tambi\u00e9n te ayudar\u00e1 a reforzar tus conocimientos.\n\nEn general, es importante que te esfuerces por brindar respuestas completas y detalladas en tus ejercicios. No dudes en hacer preguntas si no entiendes algo o necesitas orientaci\u00f3n adicional. Estoy aqu\u00ed para ayudarte y asegurarme de que alcances tu m\u00e1ximo potencial en ciencias de la computaci\u00f3n.\n\n\u00a1Sigue adelante con tu trabajo y esfuerzo, estoy seguro de que lograr\u00e1s grandes cosas en este campo emocionante!\n\nSaludos cordiales,\n\n[Nombre del profesor]"
    },
    {
        "user_id": "123",
        "user_name": "Test User",
        "user_email": "test@example.com",
        "exercise_id": "sample_exercise",
        "response": "Test answer",
        "evaluated_response": "Estimado estudiante,\n\nGracias por tu respuesta al ejercicio. Aprecio tu esfuerzo por participar, sin embargo, me gustar\u00eda ofrecerte algunos comentarios para ayudarte a mejorar en tus habilidades en inform\u00e1tica.\n\nEn primer lugar, not\u00e9 que tu respuesta fue bastante breve y no abord\u00f3 directamente el contenido del ejercicio. Para un estudiante avanzado en ciencias de la computaci\u00f3n, se espera que puedas aplicar la teor\u00eda y los conceptos aprendidos de manera pr\u00e1ctica. Te recomendar\u00eda que revisaras el enunciado del ejercicio y trataras de ofrecer una respuesta m\u00e1s detallada y espec\u00edfica que demuestre tu comprensi\u00f3n de los conceptos involucrados.\n\nAdem\u00e1s, ser\u00eda de gran ayuda si pudieras explicar tu razonamiento detr\u00e1s de tu respuesta. Esto no solo mostrar\u00e1 tu comprensi\u00f3n, sino que tambi\u00e9n te ayudar\u00e1 a mejorar tu habilidad para comunicar tus ideas de manera clara y concisa.\n\nPor otro lado, me gustar\u00eda elogiar tu iniciativa por participar en el ejercicio. Es importante que como estudiante te involucres activamente en el proceso de aprendizaje y te esfuerces por mejorar en tus habilidades en inform\u00e1tica.\n\nEn resumen, te recomiendo que revises el enunciado del ejercicio y trates de ofrecer una respuesta m\u00e1s detallada y espec\u00edfica que demuestre tu comprensi\u00f3n de los conceptos. Tambi\u00e9n te aliento a expresar tu razonamiento detr\u00e1s de tu respuesta para mejorar tu habilidad para comunicar tus ideas. \u00a1Sigue as\u00ed y ver\u00e1s una mejora en tus habilidades en inform\u00e1tica!\n\nSi tienes alguna pregunta o necesitas m\u00e1s orientaci\u00f3n, no dudes en hacerla. Estoy aqu\u00ed para ayudarte en tu proceso de aprendizaje.\n\nSinceramente, \n[Nombre del profesor de inform\u00e1tica]"
    },
    {
        "user_id": "101939652595892022773",
        "user_name": "Mat\u00edas",
        "user_email": "matuteiglesias@gmail.com",
        "exercise_id": "57",
        "response": "esta es una prueba de funcionamiento de la plataforma - ignora el mensaje",
        "evaluated_response": "Estimado estudiante,\n\nGracias por tu respuesta. Entiendo que est\u00e1s tratando de probar el funcionamiento de la plataforma, pero como este es un ejercicio de inform\u00e1tica, es importante que te enfoques en la tarea asignada. Te sugerir\u00eda que vuelvas a revisar el ejercicio y lo completes de acuerdo a las instrucciones.\n\nEn general, tu respuesta carece de contenido y no demuestra un conocimiento s\u00f3lido en ciencias de la computaci\u00f3n. Para un estudiante avanzado en esta \u00e1rea, se espera una comprensi\u00f3n te\u00f3rica profunda y la capacidad de aplicar los conceptos en situaciones pr\u00e1cticas.\n\nPara mejorar, te recomiendo que revises tus conocimientos te\u00f3ricos sobre el tema del ejercicio y practiques la aplicaci\u00f3n de los conceptos en ejercicios similares. Tambi\u00e9n es importante que prestes atenci\u00f3n a los detalles y sigas las instrucciones con cuidado.\n\nSin embargo, aprecio tu inter\u00e9s en probar la plataforma y te animo a seguir esforz\u00e1ndote en tus estudios de inform\u00e1tica. Con dedicaci\u00f3n y pr\u00e1ctica, estoy seguro de que podr\u00e1s mejorar tus habilidades y lograr un buen desempe\u00f1o en esta materia.\n\nSi tienes alguna pregunta o necesitas m\u00e1s orientaci\u00f3n, no dudes en comunicarte conmigo. Estoy aqu\u00ed para ayudarte y apoyarte en tu aprendizaje.\n\nSigue adelante y contin\u00faa esforz\u00e1ndote, estoy seguro de que lograr\u00e1s grandes resultados.\n\n\u00a1Mucho \u00e1nimo!\n\nAtentamente,\n[Nombre del profesor]"
    }
]./readme.md

### Documentación para Usuarios

#### Introducción

**Visión General de la Plataforma**

Esta plataforma educativa está diseñada para ofrecer a estudiantes y docentes una herramienta interactiva de aprendizaje y enseñanza. A través de ejercicios prácticos y feedback inmediato, busca mejorar la comprensión de conceptos complejos y fomentar el desarrollo de habilidades de resolución de problemas.

**Propósito y Público Objetivo**

Dirigida principalmente a estudiantes de informática y áreas relacionadas, la plataforma es también una valiosa herramienta para docentes que buscan complementar sus métodos de enseñanza con recursos interactivos. Adecuada para diversos niveles de conocimiento, desde principiantes hasta avanzados.


#### Requisitos del Sistema

Para acceder a nuestra plataforma educativa, lo único que necesitas es:

- **Un navegador web actualizado:** Recomendamos el uso de Google Chrome, Mozilla Firefox, o Safari para una experiencia óptima.
- **Conexión a internet:** Para poder acceder a los contenidos y funciones de la plataforma.

#### Cómo Acceder a la Plataforma

La plataforma se accede a través de una URL que te será proporcionada por tu institución educativa o por tu docente. No hay necesidad de instalar ningún software adicional, todo lo que necesitas es tu navegador web y conexión a internet.

#### Navegando por la Plataforma

##### Vista General del Tablero

(no implementado)

Una vez que ingreses a la plataforma, te encontrarás con un tablero diseñado de manera intuitiva, donde podrás ver:

- **Unidades o Temas:** Un listado de las diferentes unidades o temas disponibles para estudiar.
- **Ejercicios y Actividades:** Acceso directo a ejercicios y actividades diseñadas para reforzar tu aprendizaje.
- **Tu Progreso:** Información sobre tu progreso en ejercicios previos, incluyendo calificaciones y retroalimentación.

#### Cómo Localizar y Seleccionar Ejercicios

Para empezar a trabajar en un ejercicio específico:

1. **Selecciona la Unidad o Tema:** En el tablero principal, navega hasta la sección que corresponde a la unidad o tema que te interesa.
2. **Explora los Ejercicios Disponibles:** Dentro de cada sección encontrarás una lista de ejercicios. Puedes leer un breve resumen de lo que trata cada uno para decidir cuál te gustaría intentar resolver.
3. **Accede al Ejercicio:** Una vez que selecciones un ejercicio, encontrarás instrucciones detalladas para su resolución. En algunos casos, también podrás acceder a consejos o pistas que te ayudarán a avanzar si te encuentras atascado.

Esta guía inicial te ayudará a familiarizarte con la plataforma y a comenzar a explorar los diversos recursos educativos que ofrece. Recuerda que la práctica constante y la exploración activa son claves para un aprendizaje efectivo.



Para clarificar tu inquietud y estructurar mejor la documentación técnica (para desarrolladores), vamos a dividirla en secciones clave y luego abordaremos tus preguntas específicas sobre el manejo de las claves API y la autenticación con Google. 


### Documentación Técnica para Desarrolladores

Esta documentación está destinada a guiar a los desarrolladores en la instalación, configuración y despliegue de la aplicación. Asegúrese de seguir cada paso cuidadosamente para configurar el entorno de desarrollo o producción adecuadamente.

#### Instalación del Software y sus Dependencias

1. **Clonar el Repositorio**: Comience clonando el repositorio de la aplicación a su máquina local o servidor.

   ```bash
   git clone <url-del-repositorio>
   cd <directorio-del-proyecto>
   ```

2. **Entorno Python**: Asegúrese de tener Python 3.8 o superior instalado. Se recomienda utilizar un entorno virtual para la instalación de las dependencias.

   ```bash
   python -m venv venv
   source venv/bin/activate  # En Windows use `venv\Scripts\activate`
   ```

3. **Instalar Dependencias**: Instale todas las dependencias requeridas utilizando `pip`.

   ```bash
   pip install -r requirements.txt
   ```

#### Configuración del Entorno

1. **Variables de Entorno**: Duplique el archivo `.env.example` proporcionado en el repositorio y renómbrelo a `.env`. Rellene las variables de entorno necesarias.

   ```plaintext
   OPENAI_API_KEY=your_openai_api_key_here
   GOOGLE_CLIENT_ID=your_google_client_id_here
   GOOGLE_CLIENT_SECRET=your_google_client_secret_here
   OAUTHLIB_INSECURE_TRANSPORT=1  # Solo para propósitos de desarrollo
   ```

2. **Configuración Adicional**: Si la aplicación requiere configuraciones adicionales, asegúrese de revisar y ajustar los archivos de configuración correspondientes.

#### Uso de Docker (Opcional)

Si prefiere desplegar la aplicación utilizando Docker, siga estos pasos:

1. **Construir la Imagen Docker**: Asegúrese de tener Docker instalado y luego construya la imagen de la aplicación.

   ```bash
   docker build -t nombre-de-tu-aplicacion .
   ```

2. **Ejecutar el Contenedor**: Inicie un contenedor basado en la imagen creada. Asegúrese de pasar las variables de entorno necesarias.

   ```bash
   docker run -d -p 5000:5000 --env-file .env nombre-de-tu-aplicacion
   ```

#### Iniciar la Aplicación

1. **Directamente en su Entorno**:

   Para iniciar la aplicación directamente en su entorno, ejecute:

   ```bash
   flask run
   ```

   Esto iniciará el servidor de desarrollo de Flask y la aplicación estará accesible en `http://localhost:5000`.

2. **Utilizando Docker**:

   Si ha optado por usar Docker, el contenedor iniciado en los pasos anteriores ya debería estar ejecutando la aplicación y accesible en `http://localhost:5000`.

#### Soporte y Contribuciones

Para cualquier problema, pregunta o contribución, por favor abra un issue en el repositorio de GitHub o envíe un pull request con sus mejoras o correcciones.

Siguiendo estas instrucciones, debería ser capaz de configurar y ejecutar la aplicación en su entorno de desarrollo o producción. Recuerde mantener seguras sus claves API y credenciales, y nunca las suba a repositorios públicos.

./terminos-de-servicio.txt
# Términos de Servicio de Nuestra Aplicación Web

## Introducción

Al acceder y utilizar nuestra aplicación web, usted acepta estar sujeto a estos Términos de Servicio, todas las leyes y regulaciones aplicables, y acepta que es responsable del cumplimiento de cualquier ley local aplicable. Si no está de acuerdo con alguno de estos términos, se le prohíbe usar o acceder a este sitio.

## Uso de la Licencia

Se otorga permiso para descargar temporalmente una copia de los materiales (información o software) en la aplicación web de teacher-app para visualización transitoria personal y no comercial únicamente. Esta es la concesión de una licencia, no una transferencia de título, y bajo esta licencia usted no puede:

- modificar o copiar los materiales;
- usar los materiales para cualquier propósito comercial, o para cualquier exhibición pública (comercial o no comercial);
- intentar descompilar o revertir ingeniería cualquier software contenido en la aplicación web de teacher-app;
- remover cualquier derecho de autor u otras notaciones de propiedad de los materiales; o
- transferir los materiales a otra persona o 'espejar' los materiales en cualquier otro servidor.

Esta licencia terminará automáticamente si usted viola alguna de estas restricciones y puede ser terminada por teacher-app en cualquier momento. Al terminar su visualización de estos materiales o al terminar esta licencia, usted debe destruir cualquier material descargado en su posesión, ya sea en formato electrónico o impreso.

## Descargo de Responsabilidad

Los materiales en la aplicación web de teacher-app se proporcionan 'tal cual'. teacher-app no ofrece garantías, expresadas o implícitas, y por este medio niega y niega todas las otras garantías, incluyendo sin limitación, garantías implícitas o condiciones de comerciabilidad, adecuación para un propósito particular, o no infracción de propiedad intelectual u otra violación de derechos.

## Limitaciones

En ningún caso teacher-app o sus proveedores serán responsables por cualquier daño (incluyendo, sin limitación, daños por pérdida de datos o beneficio, o debido a interrupción del negocio) que surja del uso o la incapacidad de usar los materiales en la aplicación web de teacher-app, incluso si teacher-app o un representante autorizado de teacher-app ha sido notificado oralmente o por escrito de la posibilidad de dicho daño.

## Enlaces

teacher-app no ha revisado todos los sitios vinculados a su aplicación web y no es responsable del contenido de ningún sitio vinculado. La inclusión de cualquier enlace no implica respaldo por parte de teacher-app del sitio. El uso de cualquier sitio web vinculado es a riesgo del usuario.

## Modificaciones

teacher-app puede revisar estos términos de servicio para su aplicación web en cualquier momento sin previo aviso. Al usar esta aplicación web, usted acepta estar sujeto a la versión actual de estos Términos de Servicio.

## Contacto

Si tiene alguna pregunta sobre estos Términos de Servicio, por favor, contáctenos a través de nuestra página de contacto en la aplicación.

./check.py
import pandas as pd
from flask import jsonify, request
import os
import openai
from dotenv import load_dotenv

def get_exercises():
    df = pd.read_csv('./exercises/exercises.csv')
    return jsonify(df.to_dict(orient='records'))

def preprocess_latex_for_mathjax(latex_content):
    # Simple replacement; for demonstration purposes only
    # A robust solution would require actual LaTeX parsing
    latex_content = latex_content.replace(r'\begin{enumerate}', '<ol>')
    latex_content = latex_content.replace(r'\end{enumerate}', '</ol>')
    latex_content = latex_content.replace(r'\item', '<li>')
    # Close the list item
    latex_content = latex_content.replace(r'</li><li>', '</li>\n<li>')
    latex_content = latex_content.replace(r'\begin{center}', '<div style="text-align: center;">').replace(r'\end{center}', '</div>')
    return latex_content


def get_exercise_content(filename):
    # Assuming your exercise text files are stored in a directory named 'exercises'
    exercises_dir = 'exercises'
    filepath = os.path.join(exercises_dir, filename)
    try:
        with open(filepath, 'r', encoding='utf-8') as file:
            content = file.read()
            # Optional: Wrap LaTeX content in delimiters here if necessary
            content = preprocess_latex_for_mathjax(content)
            return content
    except FileNotFoundError:
        return "Exercise content not found."
    

    # print("Current user session data:", session.get('user'))

    # if 'user' not in session:
    #     return redirect(url_for('login'))

    # user_details = session.get('user')
    # if not user_details:
    #     print("User details not found in session.")
    #     return redirect(url_for('index'))

    exercise_id = request.form.get('exercise_id')
    response = request.form.get('response')

# Fetch the exercise content based on the exercise_id
exercise_content = get_exercise_content('57')

response = 'This is a sample response to the exercise.'

# from evaluator import Evaluator
# evaluator = Evaluator()
# evaluated_response = evaluator.evaluate(exercise_content, response)


system_instructions = {
    "role": "system",
    "content": "You are an AI tutor evaluating a student's response to a computer science exercise. Provide detailed, constructive feedback focusing on both strengths and areas for improvement. Offer specific examples for enhancing the algorithm or addressing special cases. Recommend resources like readings, tutorials, or online tools for further exploration. Your feedback should incorporate academic and practical considerations in computer science, suitable for advanced students. Provide guidance in Spanish (Argentina) and assume a supportive and encouraging tone to foster a positive learning environment. Aim to stimulate reflection and initiative, including practical and theoretical recommendations to support academic and professional development. Encourage the examination of case studies or practical examples for a deeper, applied understanding of concepts. Suggest additional resources to enrich learning and promote a problem-solving approach."
}


# completion = openai.Completion.create(
#     # engine="gpt-3.5-turbo-instruct",  # Adjust based on the available engines
#     engine="gpt-4-turbo-preview",  # Updated to use a GPT-4 model variant
#     prompt=prompt,
#     temperature=0.7,
#     max_tokens=550,
#     n=1,
#     stop=None
# )
# evaluated_response = completion.choices[0].text.strip()

def construct_prompt(exercise_content, response):
    # Introduction to the exercise and response for a conversational context
    prompt_introduction = (
        "A continuación, se presenta una respuesta de un estudiante a un ejercicio de ciencias de la computación. "
        "Basándote en criterios académicos de alto nivel y enfocándome en proporcionar un feedback constructivo, "
        "analiza la respuesta, destacando los aspectos positivos y señalando áreas de mejora. "
        "Además, ofrece recomendaciones para profundizar en la comprensión de los conceptos tratados. "
    )
    
    # Incorporating the exercise content and student's response
    exercise_and_response = (
        f"Ejercicio:\n{exercise_content}\n\n"
        f"Respuesta del estudiante:\n{response}\n\n"
    )
    
    # Instructions for AI on how to proceed with the evaluation
    evaluation_instructions = (
        "Evalúa la respuesta siguiendo estas directrices, equilibrando comentarios positivos con áreas de mejora. "
        "Proporciona ejemplos concretos de cómo mejorar el algoritmo o abordar casos especiales y orienta hacia recursos específicos que puedan explorar para reforzar los conceptos discutidos. "
        "Promueve un ambiente de aprendizaje positivo, estimulando la reflexión y la iniciativa por parte del estudiante."
    )
    
    # Combining all parts into the final prompt
    complete_prompt = f"{prompt_introduction}{exercise_and_response}{evaluation_instructions}"
    return complete_prompt




chat_completion = openai.ChatCompletion.create(
    model="gpt-4-turbo-preview",  # Specify the chat model
    messages=[
        system_instructions,
        {"role": "user", "content": construct_prompt(exercise_content, response)}
    ],
    temperature=0.7,
    max_tokens=550,
    n=1,
    stop=None
)
            
# evaluated_response = completion.choices[0].text.strip()
# Correctly accessing the response message content
evaluated_response = chat_completion.choices[0].message['content'].strip()

print(evaluated_response)
./exercises/placeholder.txt
Placeholder Exercise Text.
./exercises/SelecciondeActividades.txt
\item  Dado un conjunto de actividades $\mathcal{A} = \{A_1, \ldots, A_n\}$, el problema de selección de actividades consiste en encontrar un subconjunto de actividades $\mathcal{S}$ de cardinalidad máxima, tal que ningún par de actividades de $\mathcal{S}$ se solapen en el tiempo.  Cada actividad $A_i$ se realiza en algún intervalo de tiempo $(s_i, t_i)$, siendo $s_i \in \mathbb{N}$ su momento inicial y $t_i \in \mathbb{N}$ su momento final.  Suponemos que $1 \leq s_i < t_i \leq 2n$ para todo $1 \leq i \leq n$.

 \begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
  \item Considerar la siguiente analogía con el problema de la fiesta: cada posible actividad es un invitado y dos actividades pueden ``invitarse'' a la fiesta cuando no se solapan en el tiempo.  A partir de esta analogía, proponga un algoritmo de \textit{backtracking} para resolver el problema de selección de actividades.  ¿Cuál es la complejidad del algoritmo?

  \item Supongamos que $\mathcal{A}$ está ordenado por orden de comienzo de la actividad, i.e., $s_i \leq s_{i+1}$ para todo $1 \leq i < n$.  Escribir una función recursiva $\ActividadesPD(\mathcal{A}, \mathcal{S}, i)$ que encuentre el conjunto máximo de actividades seleccionables que contenga a $\mathcal{S} \subseteq \{A_1, \ldots, A_{i-1}\}$ y que se obtenga agregando únicamente actividades de $\{A_i, \ldots, A_{n}\}$.  \textbf{Para reflexionar:} ¿por qué se puede definir $\ActividadesPD$ en este caso y no en el inciso~\ref{ej:ind set:dp} del Ejercicio~\ref{ej:ind set}?
  \label{actividadesFormRec}

  \item Implementar un algoritmo de programación dinámica para el problema de selección de actividades que se base en la función del inciso \ref{actividadesFormRec}. ¿Cuál es su complejidad temporal y cuál es el espacio extra requerido?

 \item Considerar la siguiente estrategia golosa para resolver el problema de selección de actividades: elegir la actividad cuyo momento final sea lo más temprano posible, de entre todas las actividades que no se solapen con las actividades ya elegidas.  Demostrar que un algoritmo goloso que implementa la estrategia anterior es correcto. \textbf{Ayuda:} demostrar por inducción que la solución parcial $B_1, \ldots, B_i$ que brinda el algoritmo goloso en el paso $i$ se puede extender a una solución óptima.  Para ello, suponga en el paso inductivo que $B_1, \ldots, B_i, B_{i+1}$ es la solución golosa y que $B_1, \ldots, B_i, C_{i+1}, \ldots, C_{j}$ es la extensión óptima que existe por inducción y muestre que $B_1, \ldots, B_{i+1}, C_{i+2}, \ldots, C_j$ es una extensión óptima de $B_1, \ldots, B_{i+1}$.

  \item Mostrar una implementación del algoritmo cuya complejidad temporal sea $\mathcal{O}(n)$.
 \end{enumerate}
./exercises/SumadeSubconjuntos_bmarkFeedback.txt

Retroalimentación del Ejercicio
Tu Feedback

Tu esfuerzo en abordar este complejo problema de suma de subconjuntos se nota y es valioso, ¡buen trabajo en tu intento! Ahora, vamos a profundizar un poco en cada punto para que puedas fortalecer tu comprensión y habilidades.

Conjunto de soluciones candidatas: Identificaste correctamente las soluciones candidatas como representaciones binarias de los subconjuntos posibles de C. Tu entendimiento de la representación binaria es correcto; cada bit en tu vector representa la inclusión (1) o exclusión (0) de un elemento en el subconjunto.

Conjunto de soluciones válidas: Aquí también identificaste correctamente algunas soluciones válidas. Para una revisión exhaustiva, podrías considerar la posibilidad de enumerar todas las combinaciones y verificar su suma. En este caso, las soluciones que encontraste son correctas.

Conjunto de soluciones parciales: Tu interpretación de las soluciones parciales es un buen comienzo. Sin embargo, una solución parcial puede considerarse en cualquier etapa del proceso de toma de decisiones, lo que significa que algunos de tus ejemplos (como (1,1)) ya representan soluciones completas para el tamaño de tu subconjunto. Las soluciones parciales son más bien todas las posibles combinaciones de decisiones tomadas hasta un punto, independientemente de si completan la suma o no.

Dibujo del árbol de backtracking: Este es un aspecto desafiante. Te sugiero mirar ejemplos de árboles de decisión en recursos como libros de texto de algoritmos. Un buen punto de partida podría ser el capítulo sobre técnicas de backtracking en "Introduction to Algorithms" de Cormen et al., aunque debes verificar su disponibilidad y pertinencia. Dibujar tu propio árbol basado en el problema dado, comenzando con el nodo raíz (sin decisiones tomadas) y expandiéndote a cada decisión de incluir o no incluir un elemento, te ayudará a visualizar mejor el proceso.

Función recursiva y árbol de llamadas recursivas: Tu explicación y reconocimiento de la complejidad de la función (\SubsetSum) muestran una buena base. Para diferenciar entre el árbol de backtracking y el de llamadas recursivas, piensa en el árbol de llamadas recursivas como una representación de cómo la función se invoca a sí misma, incluyendo todas las ramificaciones posibles, mientras que el árbol de backtracking se centra en la exploración de soluciones candidatas.

Implementación y optimización: La implementación de la regla de factibilidad es un paso en la dirección correcta para optimizar el proceso de backtracking. Otra regla de factibilidad podría ser considerar la suma de todos los elementos restantes; si incluso sumando todos ellos no se alcanza (k), no tiene sentido continuar por esa rama. Respecto a imprimir el subconjunto que suma (k), tu idea de añadir y quitar elementos es correcta. Una forma de hacerlo eficientemente es mantener un vector de solución parcial global o pasar una copia modificada del vector a cada llamada recursiva.

Para profundizar en estos conceptos y mejorar tu comprensión y habilidades prácticas, te recomendaría estudiar más ejemplos de backtracking y explorar problemas similares en libros de algoritmos o en sitios de práctica de programación como LeetCode o CodeSignal. Estos problemas prácticos te darán una mejor intuición y te ayudarán a entender cómo aplicar estas técnicas en diferentes contextos.

¡Sigue trabajando duro y explorando estos conceptos! Tu curiosidad y esfuerzo son clave para tu éxito en ciencias de la computación.

Revisa tu respuesta y continúa practicando para mejorar.

./exercises/allejs.txt

\subsection*{\textit{Backtracking}}

\begin{enumerate}[label=$\arabic*$.,ref=$\arabic*$]
% \newcommand{\thechapter}{1}
% \renewcommand{\theenumi}{\thechapter.\arabic{enumi}}




\item Un \emph{cuadrado mágico de orden $n$}, es un cuadrado con los números $\{1, \ldots, n^2\}$, tal que todas sus filas, columnas y las dos diagonales suman lo mismo (ver figura).  El número que suma cada fila es llamado \emph{número mágico}.

 \begin{center}
  \begin{tabular}{|c|c|c|}
   \hline
   2 & 7 & 6 \\ \hline
   9 & 5 & 1 \\ \hline
   4 & 3 & 8 \\ \hline
  \end{tabular}
 \end{center}

 Existen muchos métodos para generar cuadrados mágicos.  El objetivo de este ejercicio es contar cuántos cuadrados mágicos de orden $n$ existen.

 \begin{enumerate}
  \item ¿Cuántos cuadrados habría que generar para encontrar todos los cuadrados mágicos si se utiliza una solución de fuerza bruta?
  \item Enunciar un algoritmo que use \textit{backtracking} para resolver este problema que se base en la siguientes ideas:

  \begin{itemize}
   \item La solución parcial tiene los valores de las primeras $i-1$ filas establecidos, al igual que los valores de las primeras $j$ columnas de la fila $i$.
   \item Para establecer el valor de la posición $(i,j+1)$ (o $(i+1,1)$ si $j = n$ e $i \neq n$) se consideran todos los valores que aún no se encuentran en el cuadrado.  Para cada valor posible, se establece dicho valor en la posición y se cuentan todos los cuadrados mágicos con esta nueva solución parcial.
  \end{itemize}

  Mostrar los primeros dos niveles del árbol de \textit{backtracking} para $n = 3$.

  \item Demostrar que el árbol de \textit{backtracking} tiene $\mathcal{O}((n^2)!)$ nodos en peor caso.
  \item\label{ej:magico:it:back} Considere la siguiente poda al árbol de \textit{backtracking}: al momento de elegir el valor de una nueva posición, verificar que la suma parcial de la fila no supere el número mágico.  Verificar también que la suma parcial de los valores de las columnas no supere el número mágico. Introducir estas podas al algoritmo e implementarlo en la computadora.  ¿Puede mejorar estas podas?
  \item\label{ej:magico:it:back2} Demostrar que el número mágico de un cuadrado mágico de orden $n$ es siempre $(n^3 + n)/2$. Adaptar la poda del algoritmo del ítem anterior para que tenga en cuenta esta nueva información.  Modificar la implementación y comparar los tiempos obtenidos para calcular la cantidad de cuadrados mágicos.
 \end{enumerate}

\item Dada una matriz simétrica $M$ de $n \times n$ números naturales y un número $k$, queremos encontrar un subconjunto $I$ de $\{1, \ldots, n\}$ con $|I| = k$ que maximice $\sum_{i,j \in I} M_{ij}$.  Por ejemplo, si $k = 3$ y:
\begin{displaymath}
    M = \begin{pmatrix}
          0 & 10 & 10 & 1 \\
          - &  0 &  5 & 2 \\
          - &  - &  0 & 1 \\
          - &  - &  - & 0
        \end{pmatrix},
\end{displaymath}
entonces $I = \{1,2,3\}$ es una solución óptima.


\begin{enumerate}
 \item Diseñar un algoritmo de \emph{backtracking} para resolver el problema, indicando claramente cómo se codifica una solución candidata, cuáles soluciones son válidas y qué valor tienen, qué es una solución parcial y cómo se extiende cada solución parcial.
 \item Calcular la complejidad temporal y espacial del mismo.
 \item Proponer una poda por optimalidad y mostrar que es correcta.
\end{enumerate}

\item Dada una matriz $D$ de $n \times n$ números naturales, queremos encontrar una permutación $\pi$\footnote{Una permutacion de un conjunto finito $X$ es simplemente una función biyectiva de $X$ en $X$.} de $\{1, \ldots, n\}$ que minimice $D_{\pi(n)\pi(1)} + \sum_{i=1}^{n-1} D_{\pi(i)\pi(i+1)}$.  Por ejemplo, si
\begin{displaymath}
    D = \begin{pmatrix}
          0  &  1 & 10 & 10 \\
          10 &  0 &  3 & 15 \\
          21 &  17 &  0 & 2 \\
           3 &  22 & 30 & 0
        \end{pmatrix},
\end{displaymath}
entonces $\pi(i) = i$ es una solución optima.

\begin{enumerate}
 \item Diseñar un algoritmo de \emph{backtracking} para resolver el problema, indicando claramente cómo se codifica una solución candidata, cuáles soluciones son válidas y qué valor tienen, qué es una solución parcial y cómo se extiende cada solución parcial.
 \item Calcular la complejidad temporal y espacial del mismo.
 \item Proponer una poda por optimalidad y mostrar que es correcta.
\end{enumerate}

\end{enumerate}

\subsection*{Programación dinámica (y su relación con \textit{backtracking})}

\begin{enumerate}[resume*]

\item\label{ej:subset sum dp} En este ejercicio vamos a resolver el problema de suma de subconjuntos usando la técnica de programación dinámica.

 \begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
  \item\label{ej:subset sum dp:recursion} Sea $n = |C|$ la cantidad de elementos de $C$.  Considerar la siguiente función recursiva $\SubsetSumPD_C \colon \{0,\ldots, n\} \times \{0, \ldots, k\} \to \{V,F\}$ (donde $V$ indica verdadero y $F$ falso) tal que:
  \begin{displaymath}
   \SubsetSumPD_C(i, j) = \begin{cases}
    j = 0 & \text{si $i = 0$} \\
    \SubsetSumPD_C(i-1,j) & \text{si $i \neq 0 \land C[i] > j$} \\
    \SubsetSumPD_C(i-1, j) \lor \SubsetSumPD_C(i-1, j- C[i]) & \text{si no}
   \end{cases}
  \end{displaymath}
  Convencerse de que esta es una definición equivalente de la función $\SubsetSum$ del inciso~\ref{sumaDeSubconjuntosFormRecBT} del Ejercicio~\ref{ejercicioSumaDeSubconjuntos}, observando que $\SubsetSum(C, k) = \SubsetSumPD_C(n, k)$.  En otras palabras, convencerse de que el algoritmo del inciso \ref{sumaDeSubconjuntosAlgoBT} es una implementación por \textit{backtracking} de la función $\SubsetSumPD_C$.  Concluir, pues, que $\mathcal{O}(2^n)$ llamadas recursivas de $\SubsetSumPD_C$ son suficientes para resolver el problema.
  \item Observar que, como $C$ no cambia entre llamadas recursivas, existen $\mathcal{O}(nk)$ posibles entradas para $\SubsetSumPD_C$. Concluir que, si $k \ll 2^n/n$, entonces necesariamente algunas instancias de $\SubsetSumPD_C$ son calculadas muchas veces por el algoritmo del inciso \ref{sumaDeSubconjuntosAlgoBT}. Mostrar un ejemplo donde se calcule varias veces la misma instancia.
  \item Considerar la estructura de memoización (i.e., el diccionario) $M$ implementada como una matriz de $(n+1) \times (k+1)$ tal que $M[i,j]$ o bien tiene un valor indefinido $\bot$ o bien tiene el valor $\SubsetSumPD_C(i, j)$, para todo $0 \leq i \leq n$ y $0 \leq j \leq k$.  Convencerse de que el siguiente algoritmo \emph{top-down} mantiene un estado válido para $M$ y computa $M[i, j] = \SubsetSumPD_C(i, j)$ cuando se invoca $\SubsetSumPD_C(i, j)$.

  \begin{enumerate}
   \item Inicializar $M[i,j] = \bot$ para todo $0 \leq i \leq n$ y $0 \leq j \leq k$.
   \item $\SubsetSumAlg(C, i, j)$: // implementa $\SubsetSum(\{c_1, \ldots, c_i\}, j) = \SubsetSumPD_C(i,  j)$ usando memoización
   \item ~~~~Si $j < 0$, retornar \textbf{falso}
   \item ~~~~Si $i = 0$, retornar $(j = 0)$
   \item ~~~~Si $M[i, j] = \bot$:
   \item ~~~~~~~~Poner $M[i, j] = \SubsetSumAlg(C, i-1, j) \lor \SubsetSumAlg(C, i-1, j - C[i])$
   \item ~~~~Retornar $M[i, j]$
  \end{enumerate}

  \item Concluir que $\SubsetSumAlg(C, n, k)$ resuelve el problema.  Calcular la complejidad y compararla con el algoritmo $\SubsetSumAlg$ del inciso \ref{sumaDeSubconjuntosAlgoBT} del Ejercicio \ref{ejercicioSumaDeSubconjuntos}. ¿Cuál algoritmo es mejor cuando $k \ll 2^n$?  ¿Y cuándo $k \gg 2^n$?

  \item Supongamos que queremos computar todos los valores de $M$.  Una vez computados, por definición, obtenemos que
  \begin{displaymath}
   M[i,j] \stackrel{\rm def}{=} \SubsetSumPD_C(i, j) \stackrel{\SubsetSumPD}{=} \SubsetSumPD_C(i-1, j) \lor \SubsetSumPD_C(i-1, j-C[i]) \stackrel{\rm def}{=} M[i-1, j] \lor M[i-1, j-C[i]]
  \end{displaymath}
  cuando $i > 0$, asumiendo que $M[i-1, j-C[i]]$ es falso cuando $j-C[i] < 0$.  Por otra parte, $M[0, 0]$ es verdadero, mientras que $M[0, j]$ es falso para $j > 0$.  A partir de esta observación, concluir que el siguiente algoritmo \emph{bottom-up} computa $M$ correctamente y, por lo tanto, $M[i, j]$ contiene la respuesta al problema de la suma para todo $\{c_1, \ldots, c_i\}$ y $j$.

  \begin{enumerate}
   \item $\SubsetSumAlg(C, k)$: // computa $M[i,j]$ para todo $0 \leq i \leq n$ y $0 \leq j \leq k$.
   \item ~~~~Inicializar $M[0,j] := (j = 0)$ para todo $0 \leq j \leq k$.
   \item ~~~~Para $i = 1, \ldots, n$ y para $j = 0, \ldots, k$:
   \item ~~~~~~~~Poner $M[i, j] := M[i-1, j] \lor (j-C[i] \geq 0 \land M[i-1, j-C[i]])$
  \end{enumerate}
  \item (Opcional) Modificar el algoritmo \textit{bottom-up} anterior para mejorar su complejidad espacial a $O(k)$.
  \item (Opcional) Demostrar que la función recursiva del inciso~\ref{ej:subset sum dp:recursion} es correcta.  \textbf{Ayuda:} demostrar por inducción en $i$ que existe algún subconjunto de $\{c_1, \ldots, c_i\}$ que suma $j$ si y solo si $\SubsetSumPD_C(i, j) = V$.
 \end{enumerate}


\item Tenemos un multiconjunto $B$ de valores de billetes y queremos comprar un producto de costo $c$ de una máquina que no da vuelto.  Para poder adquirir el producto debemos cubrir su costo usando un subconjunto de nuestros billetes. El objetivo es pagar con el mínimo exceso posible a fin de minimizar nuestra pérdida.  Más aún, queremos gastar el menor tiempo posible poniendo billetes en la máquina. Por lo tanto, entre las opciones de mínimo exceso posible, queremos una con la menor cantidad de billetes. Por ejemplo, si $c = 14$ y $B = \{2, 3, 5, 10, 20, 20\}$, la solución es pagar 15, con exceso $1$, insertando sólo dos billetes: uno de 10 y otro de 5.

\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
 \item Considerar la siguiente estrategia por \textit{backtracking} para el problema, donde $B = \{b_1, \ldots, b_n\}$. Tenemos dos posibilidades: o agregamos el billete $b_n$, gastando un billete y quedando por pagar $c-b_n$, o no agregamos el billete $b_n$, gastando $0$ billetes y quedando por pagar $c$.  Escribir una función recursiva $\Vuelto(B, c)$ para resolver el problema, donde $\Vuelto(B, c) = (c', q)$ cuando el mínimo costo mayor o igual a $c$ que es posible pagar con los billetes de $B$ es $c'$ y la cantidad de billetes mínima es $q$.
\label{billetesFormRec}

 \item Implementar la función de \ref{billetesFormRec} en un lenguaje de programación imperativo utilizando una función recursiva con parámetros $B$, $i$, $j$ que compute $\Vuelto(\{b_1, \ldots, b_i\}, j)$.  ¿Cuál es la complejidad del algoritmo?
 \label{billetesAlgoBT}

 \item Reescribir $\Vuelto$ como una función recursiva $\VueltoPD_B(i, j) = \Vuelto(\{b_1, \ldots, b_i\}, j)$ que implemente la idea anterior \textbf{dejando fijo el parámetro $B$}.  A partir de esta función, determinar cuándo $\VueltoPD_B$ tiene la propiedad de \emph{superposición de subproblemas}.

 \item Definir una estructura de memoización para $\VueltoPD_B$ que permita acceder a $\VueltoPD_B(i, j)$ en $\mathcal{O}(1)$ tiempo para todo $0 \leq i \leq n$ y $0 \leq j \leq k$.

 \item Adaptar el algoritmo de \ref{billetesAlgoBT} para incluir la estructura de memoización.

 \item Indicar cuál es la llamada recursiva que resuelve nuestro problema y cuál es la complejidad del nuevo algoritmo.

 \item (Opcional) Escribir un algoritmo \emph{bottom-up} para calcular todos los valores de la estructura de memoización y discutir cómo se puede reducir la memoria extra consumida por el algoritmo.

 \item (Opcional) Formalmente, en este problema de vuelto hay que computar el mínimo $(\sum V, |V|)$, en orden lexicográfico, de entre los conjuntos $V \subseteq B$ tales que $\sum V \geq c$.  Demostrar que la función $\VueltoPD$ es correcta.  \textbf{Ayuda:} demostrar por inducción que $\VueltoPD(i,j) = (v,k)$ para el mínimo $(v,k)$ tal que existe un subconjunto $V$ de $\{b_1, \ldots, b_i\}$ con $\sum_V \geq j$.

\end{enumerate}


\item Astro Void se dedica a la compra de asteroides. Sea $p \in \mathbb{N}^n$ tal que $p_i$ es el precio de un asteroide el $i$-ésimo día en una secuencia de $n$ días. Astro Void quiere comprar y vender asteroides durante esos $n$ días de manera tal de obtener la mayor ganancia neta posible. Debido a las dificultades que existen en el transporte y almacenamiento de asteroides, Astro Void puede comprar a lo sumo un asteroide cada día, puede vender a lo sumo un asteroide cada día y comienza sin asteroides. Además, el Ente Regulador Asteroidal impide que Astro Void venda un asteroide que no haya comprado. Queremos encontrar la máxima ganancia neta que puede obtener Astro Void respetando las restricciones indicadas. Por ejemplo, si $p = (3, 2, 5, 6)$ el resultado es $6$ y si $p = (3,6,10)$ el resultado es $7$.  Notar que en una solución óptima, Astro Void debe terminar sin asteroides.
\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
\item Convencerse de que la máxima ganancia neta (m.g.n.), si Astro Void tiene $c$ asteroides al fin del día $j$, es:
\begin{itemize}
 \item indefinido (i.e., $-\infty$) si $c < 0$ o $c > j$, o
 \item el máximo entre:
 \begin{itemize}
  \item la m.g.n. de finalizar el día $j-1$ con $c-1$ asteroides y comprar uno en el día $j$,
  \item la m.g.n. de finalizar el día $j-1$ con $c+1$ asteroides y vender uno en el día $j$,
  \item la m.g.n. de finalizar el día $j-1$ con $c$ asteroides y no operar el día $j$.
 \end{itemize}
\end{itemize}
\label{AstroFormRec}

\item Escribir matemáticamente la formulación recursiva enunciada en \ref{AstroFormRec}. Dar los valores de los casos base en función de la restricción de que comienza sin asteroides.
\item Indicar qué dato es la respuesta al problema con esa formulación recursiva.
\item Diseñar un algoritmo de PD \emph{top-down} que resuelva el problema y explicar su complejidad temporal y espacial auxiliar.
\item (Opcional) Diseñar un algoritmo de PD \emph{bottom-up}, reduciendo la complejidad espacial.
\item (Opcional) Formalmente, el problema consiste en determinar el máximo $g = \sum_{i=1}^n x_i p_i$ para un vector $x = (x_1, \ldots, x_n)$ tal que: $x_i \in \{-1,0,1\}$ para todo $1 \leq i \leq n$ y $\sum_{i=1}^j x_i \geq 0$ para todo $1 \leq j \leq n$.  Demostrar que la formulacion recursiva es correcta. \textbf{Ayuda}: primero demostrar que existe una solución óptima en la que Astro Void se queda sin asteroides en el día $n$.  Luego, demostrar por inducción que la función recursiva respeta la semántica, i.e., que computa la m.g.n.\ al final del día $j$ cuando Astro Void posee $c$ asteroides.
\end{enumerate}

\item Debemos cortar una vara de madera en varios lugares predeterminados. Sabemos que el costo de realizar un corte en una madera de longitud $\ell$ es $\ell$ (y luego de realizar ese corte quedarán 2 varas de longitudes que sumarán $\ell$).  Por ejemplo, si tenemos una vara de longitud 10 metros que debe ser cortada a los 2, 4 y 7 metros desde un extremo, entonces los cortes se pueden realizar, entre otras maneras, de las siguientes formas:
\begin{itemize}
\item Primero cortar en la posición 2, después en la 4 y después en la 7. Esta resulta en un costo de 10 + 8 + 6 = 24 porque el primer corte se hizo en una vara de longitud 10 metros, el segundo en una de 8 metros y el último en una de 6 metros.
\item Cortar primero donde dice 4, después donde dice 2, y finalmente donde dice 7, con un costo de 10 + 4 + 6 = 20, que es menor.
\end{itemize}
\par{Queremos encontrar el mínimo costo posible de cortar una vara de longitud $\ell$.}
\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
\item Convencerse de que el mínimo costo de cortar una vara que abarca desde $i$ hasta $j$ con el conjunto $C$ de lugares de corte es $j-i$ mas el mínimo, para todo lugar de corte $c$ entre $i$ y $j$, de la suma entre el mínimo costo desde $i$ hasta $c$ y el mínimo costo desde $c$ hasta $j$.
\label{maderaFormRec1}
\item Escribir matemáticamente una formulación recursiva basada en \ref{maderaFormRec1}. Explicar su semántica e indicar cuáles serían los parámetros para resolver el problema.
\item Diseñar un algoritmo de PD y dar su complejidad temporal y espacial auxiliar. Comparar cómo resultaría un enfoque \textit{top-down} con uno \textit{bottom-up}.
\label{maderaComplejidad1}
\item Supongamos que se ordenan los elementos de $C$ en un vector $cortes$ y se agrega un $0$ al principio y un $\ell$ al final. Luego, se considera que el mínimo costo para cortar desde el $i$-ésimo punto de corte en $cortes$ hasta el $j$-ésimo punto de corte será el resultado buscado si $i = 1$ y $j = |C| + 2$.
\label{maderaFormRec2}
\begin{enumerate}[label=$\roman*)$,ref=$\roman*)$]
\item Escribir una formulación recursiva con dos parámetros que esté basada en \ref{maderaFormRec2} y explicar su semántica.
\item Diseñar un algoritmo de PD, dar su complejidad temporal y espacial auxiliar y compararlas con aquellas de \ref{maderaComplejidad1}. Comparar cómo resultaría un enfoque \textit{top-down} con uno \textit{bottom-up}.
\end{enumerate}
\end{enumerate}

\item Hay un terreno, que podemos pensarlo como una grilla de $m$ filas y $n$ columnas, con trampas y pociones. Queremos llegar de la esquina superior izquierda hasta la inferior derecha, y desde cada casilla sólo podemos movernos a la casilla de la derecha o a la de abajo. Cada casilla $i$,$j$ tiene un número entero $A_{i,j}$ que nos modificará el nivel de vida sumándonos el número $A_{i,j}$ (si es negativo, nos va a restar $|A_{i,j}|$ de vida). Queremos saber el mínimo nivel de vida con el que debemos comenzar tal que haya un camino posible de modo que en todo momento nuestro nivel de vida sea al menos 1. Por ejemplo, si tenemos la grilla
\[ A = \begin{bmatrix}
-2 & -3 & 3 \\
-5 & -10 & 1 \\
10 & 30 & -5
\end{bmatrix} \]
\par{el mínimo nivel de vida con el que podemos comenzar es 7 porque podemos realizar el camino que va todo a la derecha y todo abajo.}
\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
\item Pensar la idea de un algoritmo de \textit{backtracking} (no hace falta escribirlo).
\item Convencerse de que, excepto que estemos en los límites del terreno, la mínima vida necesaria al llegar a la posición $i, j$ es el resultado de restar al mínimo entre la mínima vida necesaria en $i+1, j$ y aquella en $i, j+1$, el valor $A_{i,j}$, salvo que eso fuera menor o igual que 0, en cuyo caso sería 1.
\label{terrenoFormRec}
\item Escribir una formulación recursiva basada en \ref{terrenoFormRec}. Explicar su semántica e indicar cuáles serían los parámetros para resolver el problema.
\item Diseñar un algoritmo de PD y dar su complejidad temporal y espacial auxiliar. Comparar cómo resultaría un enfoque \textit{top-down} con uno \textit{bottom-up}.
\item Dar un algoritmo \textit{bottom-up} cuya complejidad temporal sea $\mathcal{O}(m \cdot n)$ y la espacial auxiliar sea $\mathcal{O}(\min(m, n))$.
\end{enumerate}

\item Tenemos cajas numeradas de $1$ a $N$, todas de iguales dimensiones. Queremos encontrar la máxima cantidad de cajas que pueden apilarse en una única pila cumpliendo que:
\begin{itemize}
\item sólo puede haber una caja apoyada directamente sobre otra;
\item las cajas de la pila deben estar ordenadas crecientemente por número, de abajo para arriba;
\item cada caja $i$ tiene un peso $w_i$ y un soporte $s_i$, y el peso total de las cajas que están arriba de otra no debe exceder el soporte de esa otra.
\end{itemize}
\par{Si tenemos los pesos $w = [19, 7, 5, 6, 1]$ y los soportes $s = [15, 13, 7, 8, 2]$ (la caja 1 tiene peso 19 y soporte 15, la caja 2 tiene peso 7 y soporte 13, etc.), entonces la respuesta es 4. Por ejemplo, pueden apilarse de la forma 1-2-3-5 o 1-2-4-5 (donde la izquierda es más abajo), entre otras opciones.}

\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
\item Pensar la idea de un algoritmo de \textit{backtracking} (no hace falta escribirlo).
\item Escribir una formulación recursiva que sea la base de un algoritmo de PD. Explicar su semántica e indicar cuáles serían los parámetros para resolver el problema.
\item Diseñar un algoritmo de PD y dar su complejidad temporal y espacial auxiliar. Comparar cómo resultaría un enfoque \textit{top-down} con uno \textit{bottom-up}.
\item (Opcional) Formalizar el problema y demostrar que la función recursiva es correcta.
\end{enumerate}

\item Sea $v=(v_1, v_2, \ldots v_n)$ un vector de n\'umeros naturales, y sea $w \in \mathbb{N}$.
Se desea intercalar entre los elementos de $v$ las operaciones $+$ (suma), $\times$ (multiplicaci\'on) y $\uparrow$ (potenciaci\'on) de tal manera que al evaluar la expresi\'on obtenida el resultado sea $w$.
Para evaluar la expresi\'on se opera de izquierda a derecha ignorando la precedencia de los operadores.
Por ejemplo, si $v=(3, 1, 5, 2, 1)$, y las operaciones elegidas son $+$, $\times$, $\uparrow$ y $\times$ (en ese orden), la expresi\'on obtenida es $3 + 1 \times 5 \uparrow 2 \times 1$, que se evalúa como $(((3 + 1) \times 5) \uparrow 2) \times 1 = 400$.
\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
\item Escribir una formulación recursiva que sea la base de un algoritmo de PD que, dados $v$ y $w$, encuentre una secuencia de operaciones como la deseada, en caso de que tal secuencia exista. Explicar su semántica e indicar cuáles serían los parámetros para resolver el problema.
\label{operacionesFormRec}
\item Dise\~nar un algoritmo basado en PD con la formulación de \ref{operacionesFormRec} y dar su complejidad temporal y espacial auxiliar. Comparar cómo resultaría un enfoque \textit{top-down} con uno \textit{bottom-up}.
\item (Opcional) Formalizar el problema y demostrar que la función recursiva es correcta.
\end{enumerate}

\item Se arrojan simultáneamente $n$ dados, cada uno con $k$ caras numeradas de $1$ a $k$. Queremos calcular todas las maneras posibles de conseguir la suma total $s \in \mathbb{N}$ con una sola tirada. Tomamos dos variantes de este problema.

\begin{enumerate}[label=$(\Alph*)$,ref=$(\Alph*)$]
\item Consideramos que los dados son \textbf{distinguibles}, es decir que si $n = 3$ y $k = 4$, entonces existen $10$ posibilidades que suman $s = 6$:
\begin{enumerate}
\item $4$ posibilidades en las que el primer dado vale $1$
\item $3$ posibilidades en las que el primer dado vale $2$
\item $2$ posibilidades en las que el primer dado vale $3$
\item Una posibilidad en la que el primer dado vale $4$
\end{enumerate}\label{ejdados:distinguibles}
\item Consideramos que los dados son \textbf{indistinguibles}, es decir que si $n = 3$ y $k = 4$, entonces existen $3$ posibilidades que suman $s = 6$:
\begin{enumerate}
\item Un dado vale $4$, los otros dos valen $1$
\item Un dado vale $3$, otro $2$ y otro $1$
\item Todos los dados valen $2$
\end{enumerate}\label{ejdados:indistinguibles}
\end{enumerate}

\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
  \item Definir en forma recursiva la función $f \colon \mathbb{N}^2 \to \mathbb{N}$ tal que $f(n, s)$ devuelve la respuesta para el escenario~\ref{ejdados:distinguibles} (fijado $k$).
  \item Definir en forma recursiva la función $g \colon \mathbb{N}^3 \to \mathbb{N}$ tal que $f(n, s, k)$ devuelve la respuesta para el escenario~\ref{ejdados:indistinguibles}.
  \item Demostrar que $f$ y $g$ poseen la propiedad de superposición de subproblemas.
  \item Definir algoritmos \textit{top-down} para calcular $f(n, s)$ y $g(n, s, k)$ indicando claramente las estructuras de datos utilizadas y la complejidad resultante.
  \item Escribir el (pseudo-)código de los algoritmos top-down resultantes.
\end{enumerate}
 \textbf{Nota:} Una solución correcta de este ejercicio debería indicar cómo se computa tanto $f(n,s)$ como $g(n,s,k)$ en tiempo $O(nk\min\{s, nk\})$.

\end{enumerate}

\subsection*{Golosos ($\equiv$ avariciosos $\equiv$ \textit{greedy})}

\begin{enumerate}[resume*]
\item Tenemos dos conjuntos de personas y para cada persona sabemos su habilidad de baile. Queremos armar la máxima cantidad de parejas de baile, sabiendo que para cada pareja debemos elegir exactamente una persona de cada conjunto de modo que la diferencia de habilidad sea menor o igual a 1 (en módulo). Además, cada persona puede pertenecer a lo sumo a una pareja de baile.  Por ejemplo, si tenemos un multiconjunto con habilidades $\{ 1, 2, 4, 6 \}$ y otro con $\{ 1, 5, 5, 7, 9 \}$, la máxima cantidad de parejas es 3. Si los multiconjuntos de habilidades son $\{ 1, 1, 1, 1, 1 \}$ y $\{ 1, 2, 3 \}$, la máxima cantidad es 2.
\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
\item Considerando que ambos multiconjuntos de habilidades estan ordenados en forma creciente, observar que la solución se puede obtener recorriendo los multiconjuntos en orden para realizar los emparejamientos.
\label{baileIdea}
\item Diseñar un algoritmo goloso basado en \ref{baileIdea} que recorra una única vez cada multiconjunto. Explicitar la complejidad temporal y espacial auxiliar.
\label{baileAlgo}
\item Demostrar que el algoritmo dado en \ref{baileAlgo} es correcto.
\end{enumerate}

\item Dado un conjunto $X$ con $|X| = n$ y un entero $k\leq n$ queremos encontrar el máximo valor que pueden sumar los elementos de un subconjunto $S$ de $X$ de tamaño $k$. Más formalmente, queremos calcular $\max\limits_{S \subseteq X, |S| = k} \sum_{s \in S} s$.

\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
    \item Proponer un algoritmo \textit{greedy} que resuelva el problema, demostrando su correctitud. Extender el algoritmo para que también devuelva uno de los subconjuntos $S$ que maximiza la suma.\label{sumaIdea}
    \item Dar una implementación del algoritmo del inciso \ref{sumaIdea} con complejidad temporal $O(n\log n)$.

    \item Dar una implementación del algoritmo del inciso \ref{sumaIdea} con complejidad temporal $O(n \log k)$.
\end{enumerate}

\item Queremos encontrar la suma de los elementos de un multiconjunto de números naturales. Cada suma se realiza exactamente entre dos números $x$ e $y$ y tiene costo $x + y$.
\par{Por ejemplo, si queremos encontrar la suma de $\{ 1, 2, 5 \}$ tenemos 3 opciones:}
\begin{itemize}
\item 1 + 2 (con costo 3) y luego 3 + 5 (con costo 8), resultando en un costo total de 11;
\item 1 + 5 (con costo 6) y luego 6 + 2 (con costo 8), resultando en un costo total de 14;
\item 2 + 5 (con costo 7) y luego 7 + 1 (con costo 8), resultando en un costo total de 15.
\end{itemize}
\par{Queremos encontrar la forma de sumar que tenga costo mínimo, por lo que en nuestro ejemplo la mejor forma sería la primera.}

\begin{enumerate}
 \item Explicitar una estrategia golosa para resolver el problema.
 \item Demostrar que la estrategia propuesta resuelve el problema.
 \item Implementar esta estrategia en un algoritmo iterativo.  \textbf{Nota:} el mejor algoritmo simple que conocemos tiene complejidad $\mathcal{O}(n\log n)$ y utiliza una estructura de datos que implementa una secuencia ordenada.
\end{enumerate}

\item Tomás quiere viajar de Buenos Aires a Mar del Plata en su flamante Renault 12. Como está preocupado por la autonomía de su vehículo, se tomó el tiempo de anotar las distintas estaciones de servicio que se encuentran en el camino. Modeló el mismo como un segmento de $0$ a $M$, donde Buenos aires está en el kilómetro 0, Mar del Plata en el $M$, y las distintas estaciones de servicio están ubicadas en los kilómetros $0 = x_1 \leq x_2 \leq \ldots x_n \leq M$.

Razonablemente, Tomás quiere minimizar la cantidad de paradas para cargar nafta. Él sabe que su auto es capaz de hacer hasta $C$ kilómetros con el tanque lleno, y que al comenzar el viaje este está vacío.

\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
    
    \item Proponer un algoritmo \textit{greedy} que indique cuál es la cantidad mínima de paradas para cargar nafta que debe hacer Tomás, y que aparte devuelva el conjunto de estaciones en las que hay que detenerse. Probar su correctitud.\label{tomasIdea}

    \item Dar una implementación de complejidad temporal $O(n)$ del algoritmo del inciso \ref{tomasIdea}.
\end{enumerate}

\item En medio de una pandemia, la Escuela de Aulas Grandes y Ventiladas quiere implementar un protocolo especial de distanciamiento social que tenga en cuenta que la escuela no tienen restricciones de espacio.  El objetivo es separar a cada curso en dos subcursos a fin de reducir la cantidad de pares de estudiantes que sean muy cercanos, dado que se estima que estos estudiantes tienen dificultades para respetar tan buscado distanciamiento.  Para este fin, en el protocolo se estableció que cada curso que tenga $c$ parejas de estudiantes cercanos tiene que dividirse en dos subcursos, cada uno de los cuales puede tener a lo sumo $c/2$ parejas de estudiantes cercanos.  Notar que no importa si un subcurso queda con más estudiantes que otro.

Formalmente, para cada curso contamos con un conjunto de estudiantes $E$ y su conjunto $C$ de pares de estudiantes cercanos.  Luego, una partición $(A,B)$ de $E$ es una \emph{solución factible para $(E, C)$} cuando $|(A\times A) \cap C| \leq |C|/2$ y $|(B \times B) \cap C| \leq |C/2|$.  Por ejemplo, si $E = \{1, 2, 3, 4\}$ y $C = \{1\text{-}2, 2\text{-}3, 3\text{-}4\}$, entonces $(\{1,3,4\}, \{2\})$ y $(\{2,4\}, \{1,3\})$ son soluciones factibles.

\begin{enumerate}[label=$\alph*)$, ref=$\alph*)$]
 \item Especificar el problema descrito definiendo cuál es la instancia (i.e. cuáles son los datos de entrada y qué condiciones satisfacen) y cuál es el resultado esperado (i.e., cuáles son los datos de salida y qué condiciones satisfacen).\label{ej:aulas-grandes:entrada}
 \item Demostrar que para toda instancia existe un resultado esperado que satisface las condiciones definidas por el protocolo.  \textbf{Ayuda:} hacer inducción en la cantidad de estudiantes.  Para el paso inductivo, considerar que si les estudiantes se asignan iterativamente a los subcursos, entonces conviene enviar a cada estudiante al subcurso que tenga la menor cantidad de estudiantes cercanos a elle.
 \item A partir de la demostración del inciso anterior, diseñar un algoritmo que encuentre una solución factible en tiempo lineal en función del tamaño de la entrada definido en el inciso~\ref{ej:aulas-grandes:entrada}.
\end{enumerate}

\item Se define la función $mex: \mathcal{P}(\mathds{N}) \to \mathds{N}$ como

$$
mex(X) = \min\{j : j\in \mathds{N} \wedge j \notin X\}
$$

Intuitivamente, $mex$ devuelve, dado un conjunto $X$, el menor número natural que no está en $x$. Por ejemplo, $mex(\{0,1,2\}) = 3$, $mex(\{0, 1, 3\}) = 2$ y $mex(\{1,2,3, \ldots\}) = 0$.

Dado un vector de número $a_1 \ldots a_n$ queremos encontrar la permutación $b_1 \ldots b_n$ de los mismos que maximize

$$
\sum_{i=1}^n mex(\{b_1 \ldots b_i\})
$$

Por ejemplo, si el vector es $\{3, 0, 1\}$ podemos ver que la mejor permutación es $\{0, 1, 3\}$, que alcanza un valor de

$$
mex(\{0\}) + mex(\{0, 1\}) + mex(\{0,1,3\}) = 1+2+2 = 5
$$

\begin{enumerate}
    \item Proponer un algoritmo \textit{greedy} que resuelva el problema y demostrar su correctitud. \textbf{Ayuda}: ¿Cuál el máximo valor que puede tomar $mex(X)$ si $X$ tiene $n$ elementos? Si $X \subseteq Y$, ¿Qué pasa con los valores $mex(X)$ y $mex(Y)$?

    \item Dar una implementación del algoritmo del inciso anterior con complejidad temporal $O(n)$.
\end{enumerate}

\item Como los accesos a memoria RAM son lentos en comparación al trabajo propio del CPU, es común que se coloquen memorias intermedias más diminutas y de alta velocidad entre ambas unidades, las cuales llamamos \textit{cachés}. Cuando un programa se ejecuta y hace una consulta a la memoria por cierta posición $r$ primero se verifica si la posición $r$ está cargada en la caché, en cuyo caso el CPU la puede obtener sin tener que hacer el acceso a la RAM. Cuando esto ocurre, decimos que ocurre un \textit{caché hit}. En cambio, si la posición $r$ no está en la caché, esta se busca a memoria, se carga en la caché, y luego se la informa al CPU. A este evento se lo conoce como \textit{caché miss}.

Como la caché es más chica que la memoria RAM es inevitable que eventualmente ocurra un \textit{caché miss} y que la caché este llena. En ese caso, la caché debe decidir qué información va a desechar para darle lugar a la nueva entrada. Naturalmente, se busca minimizar la cantidad de \textit{misses} de los siguientes accesos.

El problema de \textit{Off-line} caching consiste en determinar, dada una caché $C$ de tamaño $k$ y una lista de $n$ requests $R = \{r_1, r_2, \ldots, r_n\}$\footnote{Sin pérdida de generalidad respecto al problema, podemos asumir que $1 \leq r_i \leq n$ para todo $i$.} a posiciones de memoria, qué decisión debe tomar en cada paso la caché para minimizar la cantidad de \textit{misses}. Por ejemplo, si $k=2$ y $R=\{1,2,3,1\}$ entonces:

\begin{itemize}
    \item La primera consulta es un \textit{miss}, pero como hay lugar en la caché (empieza vacía) se carga la posición 1 a $C$ ($C= \{1\}$).
    \item Con la segunda consulta pasa lo mismo, por lo que la caché queda en el estado $C= \{1, 2\}$.
    \item En la tercera consulta la caché esta llena, por lo que se debe desechar alguna entrada. Notemos que si se desecha $1$ entonces la cuarta consulta dará otro \textit{miss}, mientras que si se desecha $2$ entonces habrá un \textit{hit}.
\end{itemize}

Una política posible para decidir qué elemento desachar es la \textit{furthest-in-future}: se desecha aquella posición $r$ cuyo siguiente acceso es el más lejano (o bien, que no tiene un siguiente acceso). 

\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
    \item \textbf{Opcional}: Definir una función recursiva $f(i, mem)$ que tome un índice y un estado de la memoria y devuelva la mínima cantidad de \textit{caché misses} que deben ocurrir para procesar todas las consultas $\{r_i, r_{i+1}, \ldots, r_n\}$ si el estado actual de la memoria es $mem$ ¿Con qué llamado se resuelve el problema? Estudiar la superposición de subproblemas y explicar en qué casos vale la pena memorizar.
    
    \item Probar que la política \textit{furthest-in-future} es óptima (es decir, que minimiza la cantidad de \textit{misses}). \textbf{Ayuda}: Dada una serie de decisiones, probar que si en un paso no se sigue la política \textit{furthest} entonces podemos alterar ese paso para que sí la siga sin afectar la cantidad de \textit{misses}. 
    \item Dar un algoritmo con complejidad temporal $O(n \log (k))$ que informe qué decisión debe tomar la caché en cada paso para minimizar la cantidad de \textit{misses}.
\end{enumerate}

\end{enumerate}

\subsection*{Ejercicios integradores}

\begin{enumerate}[resume*]

\item\label{ej:ind set} El problema de la fiesta consiste en determinar un conjunto de invitados que no tengan conflictos entre sí y que sea de cardinalidad máxima.  Formalmente, dado un conjunto $V$ de posibles invitados y un conjunto $E$ de conflictos, formados por pares no ordenados de $V$, queremos encontrar un subconjunto $S \subseteq V$ de cardinalidad máxima entre aquellos que cumplen que $\{v,w\} \not\in E$ para todo par $v,w \in S$. Por ejemplo, si $S = \{1,2,3,4,5\}$ y $E = \{ \{1,2\}, \{2, 3\}, \{3, 4\}, \{4,5\} \}$, entonces una solución es $S = \{1,3,5\}$, ya que no se puede invitar a ningún conjunto de $4$ personas.  Vamos a suponer que los posibles invitados se representan con el conjunto $V = \{1, \ldots, n\}$ para algún $n \geq 0$ (el caso $n=0$ es válido y representa el conjunto $V = \emptyset$).
\label{ejercicioFiesta}

 \begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
  \item Decimos que $S \subseteq \mathbb{N}$ y $W \subseteq \mathbb{N}$ son \emph{compatibles} cuando $S \subseteq V$ es un conjunto posible de invitados y ningún elemento de $W \subseteq V \setminus S$ tiene un conflicto con algún elemento de $S$.  En el ejemplo anterior, $S = \{1\}$ y $W = \{4, 5\}$ son compatibles pero $S = \{1,4\}$ y $W = \{2\}$ no lo son.  Sea $\mathcal{V}$ el conjunto de subconjuntos de $V$.  Escribir una función recursiva $\Fiesta \colon \mathcal{V} \times \mathcal{V} \to \mathcal{V}$ tal que, dados $S$ y $W$ compatibles, $\Fiesta(S, W)$ retorne un conjunto de invitados de máxima cardinalidad que contenga a $S$.  (Notar que la llamada recursiva debe garantizar la compatibilidad).  \textbf{Ayuda:} considerar dos posibilidades: no invitar a $w \in W$, o invitar a $w \in W$ y no invitar a nadie que tenga un conflicto con $w$.
  \label{fiestaFormRec}

  \item En base a \ref{fiestaFormRec}, implementar un algoritmo recursivo de \emph{backtracking} para resolver el problema de la fiesta basado en las siguientes ideas:
  \begin{itemize}
   \item cada solución parcial es un conjunto $S \subseteq V$ que no contiene invitados con conflictos.
   \item a cada nodo del árbol de \textit{backtracking} se le asocia un conjunto $W \subseteq V$ compatible con $S$ de posibles invitados.
   \item para la extensión, se consideran dos posibilidades: o bien no se invita a $w \in W$ o bien se invita a $w$ y se eliminan de $W$ todos los otros elementos que estén en conflicto con $w$.
  \end{itemize}
  \label{fiestaAlgo1}
  \item Escribir los tres primeros niveles del árbol de \textit{backtracking} resultante de la implementación anterior.
  \item Describir una regla de optimalidad para poder podar el árbol e incluirla en la implementación de \ref{fiestaAlgo1}.
  \item\label{ej:ind set:dp} ¿Se le ocurre una forma de escribir una función recursiva $\FiestaPD(V, S, i)$ que, en analogía con el inciso~\ref{ej:subset sum dp:recursion} del Ejercicio~\ref{ej:subset sum dp}, determine el conjunto de invitados óptimo que incluya a $S \subseteq \{1, \ldots, i-1\}$ y que se obtenga agregando sólo invitados de $\{i, \ldots, n\}$? ¿Cuál es el problema?  ¿Se le ocurre alguna manera de escapar a este problema?
  \item Considerando la función $\Fiesta$ (definida en \ref{fiestaFormRec}) y el inciso anterior, observar que la cantidad posible de instancias es $\Omega(2^n)$.  Concluir que la función $\Fiesta$ no tiene la propiedad de superposición de subproblemas para el caso general del problema de la fiesta.
 \end{enumerate}

\item  Dado un conjunto de actividades $\mathcal{A} = \{A_1, \ldots, A_n\}$, el problema de selección de actividades consiste en encontrar un subconjunto de actividades $\mathcal{S}$ de cardinalidad máxima, tal que ningún par de actividades de $\mathcal{S}$ se solapen en el tiempo.  Cada actividad $A_i$ se realiza en algún intervalo de tiempo $(s_i, t_i)$, siendo $s_i \in \mathbb{N}$ su momento inicial y $t_i \in \mathbb{N}$ su momento final.  Suponemos que $1 \leq s_i < t_i \leq 2n$ para todo $1 \leq i \leq n$.

 \begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
  \item Considerar la siguiente analogía con el problema de la fiesta: cada posible actividad es un invitado y dos actividades pueden ``invitarse'' a la fiesta cuando no se solapan en el tiempo.  A partir de esta analogía, proponga un algoritmo de \textit{backtracking} para resolver el problema de selección de actividades.  ¿Cuál es la complejidad del algoritmo?

  \item Supongamos que $\mathcal{A}$ está ordenado por orden de comienzo de la actividad, i.e., $s_i \leq s_{i+1}$ para todo $1 \leq i < n$.  Escribir una función recursiva $\ActividadesPD(\mathcal{A}, \mathcal{S}, i)$ que encuentre el conjunto máximo de actividades seleccionables que contenga a $\mathcal{S} \subseteq \{A_1, \ldots, A_{i-1}\}$ y que se obtenga agregando únicamente actividades de $\{A_i, \ldots, A_{n}\}$.  \textbf{Para reflexionar:} ¿por qué se puede definir $\ActividadesPD$ en este caso y no en el inciso~\ref{ej:ind set:dp} del Ejercicio~\ref{ej:ind set}?
  \label{actividadesFormRec}

  \item Implementar un algoritmo de programación dinámica para el problema de selección de actividades que se base en la función del inciso \ref{actividadesFormRec}. ¿Cuál es su complejidad temporal y cuál es el espacio extra requerido?

 \item Considerar la siguiente estrategia golosa para resolver el problema de selección de actividades: elegir la actividad cuyo momento final sea lo más temprano posible, de entre todas las actividades que no se solapen con las actividades ya elegidas.  Demostrar que un algoritmo goloso que implementa la estrategia anterior es correcto. \textbf{Ayuda:} demostrar por inducción que la solución parcial $B_1, \ldots, B_i$ que brinda el algoritmo goloso en el paso $i$ se puede extender a una solución óptima.  Para ello, suponga en el paso inductivo que $B_1, \ldots, B_i, B_{i+1}$ es la solución golosa y que $B_1, \ldots, B_i, C_{i+1}, \ldots, C_{j}$ es la extensión óptima que existe por inducción y muestre que $B_1, \ldots, B_{i+1}, C_{i+2}, \ldots, C_j$ es una extensión óptima de $B_1, \ldots, B_{i+1}$.

  \item Mostrar una implementación del algoritmo cuya complejidad temporal sea $\mathcal{O}(n)$.
 \end{enumerate}

\end{enumerate}




\begin{enumerate}[$1)$]
 \item La cantidad de combustible consumida por un avión en un viaje dado depende en gran parte de la resistencia que ofrece el aire a la aeronave durante el trayecto. Por ello, es de interés calcular la ruta que incurra en la menor resistencia posible. En este ejemplo simplificado, un avión debe realizar un viaje de $N$ minutos entre dos ciudades. Si bien el curso está prefijado, el avión puede variar la altitud a la que viaja dentro de $H$ bandas posibles numeradas de $0$ a $H-1$. Se tiene un estimativo de la resistencia que provocará viajar durante el minuto $n$ en la banda de altitud $h$, que por simplicidad podemos suponer que tenemos en forma de una tabla $R$ donde $R[i,j]$ es un valor natural que representa la resistencia al aire esperada en el minuto $i$ de vuelo si se está en la banda de altitud $j$. Para moverse entre dos bandas de altitud, el avión debe pasar por todas las bandas intermedias. Pasar de una banda de altitud a una adyacente (da igual si es subiendo o bajando) requiere realizar una maniobra que dura 3 minutos, cuya resistencia se estima como la del minuto de salida en la banda de salida más el máximo entre las resistencias en ambas bandas durante los dos minutos siguientes, es decir, si se realiza la maniobra entre la banda $X$ y la banda $X+1$  desde el minuto 1 al minuto 4, la resistencia al aire será la del minuto 1 en la banda $X$ más el máximo entre la resistencia en la banda $X$ y en la banda $X+1$ en el minuto 2 más el máximo de la resistencia entre la banda $X$ y la banda $X+1$ en el minuto 3. Por ejemplo, para un viaje de 10 minutos con la siguiente tabla de resistencias $R$,

 \begin{center}
     \centering
     \newcommand{\myline}{\cline{3-12}}
     \newcommand{\noline}[1]{\multicolumn{1}{c}{#1}}
     \begin{tabular}{c c|c|c|c|c|c|c|c|c|c|c|}
         \noline{} & \noline{} & \multicolumn{10}{c}{minuto} \\
         \noline{} & \noline{} & \noline{0} & \noline{1} & \noline{2} & \noline{3} & \noline{4} & \noline{5} & \noline{6} & \noline{7} & \noline{8} & \noline{9}\\
         \myline
               & $2$ & $7$ & $7$ & $7$ & $6$ & $6$ & $7$ & $6$ & $6$ & $7$ & $6$\\
         \myline
         banda & $1$ & $6$ & $5$ & $4$ & $3$ & $4$ & $3$ & $4$ & $4$ & $4$ & $4$ \\
         \myline
               & $0$ & $3$ & $5$ & $5$ & $5$ & $5$ & $5$ & $5$ & $3$ & $2$ & $2$ \\
         \myline
     \end{tabular}
 \end{center}

 podemos considerar la resistencia del camino que se encuentra saliendo de la banda $0$ y subiendo en el minuto $0$, luego pasando los minutos $3$ y $4$ en la banda $1$, volviendo a bajar a la banda $0$ en el minuto $5$ y permaneciendo allí. En ese caso, la resistencia total es
 \begin{equation*}
 13 + 3 + 4 + 12 + 2 + 2 = 36
 \end{equation*}

 Donde el término de valor $13$ se calcula como $R[0,0]+\max\{R[1,0],R[1,1]\}+\max\{R[2,0],R[2,1]\}$ y el $12$ como $R[5,1]+\max\{R[6,0],R[6,1]\}+\max\{R[7,0],R[7,1]\}$.

 Se desea conocer cuál es la mínima resistencia total posible para el vuelo programado, conociendo que al inicio del viaje y al final se debe estar en la banda de altura $0$. En el ejemplo mostrado, el camino presentado es óptimo.

 \begin{enumerate}[$a)$]
  \item Definir en forma recursiva la función $f_R \colon \nat \times \nat \to \nat$ tal que $f_R(n,h)$ representa la mínima resistencia de aire total estimada que puede afrontar un avión desde el minuto $0$ hasta el minuto $n$ del vuelo proyectado, si al minuto $0$ estaba en la banda de altitud $0$ y en el momento $n$ se encuentra en la banda $h$. Indicar qué llamado(s) hay que hacer a esta función para resolver el problema. \textbf{Importante:} acompañen a la definición recursiva con una explicación en castellano.

  \item Argumentar en qué casos $f_R$ posee la propiedad de superposición de subproblemas.

  \item Definir un algoritmo \textit{top-down} para calcular $f_R(n,h)$ indicando claramente las estructuras de datos utilizadas y la complejidad resultante. Escribir el (pseudo-)código del algoritmo. ¿Es la complejidad obtenida polinomial?

  \item Sin modificar el algoritmo anterior, pero suponiendo que ya fue ejecutado, explicar cómo determinar las bandas de alturas en las que debe viajar el avión para alcanzar la resistencia mínima calculada.
 \end{enumerate}

 \textbf{Criterio de aprobación:} La función descripta en el inciso a) debe ser correcta y estar adecuadamente justificada, y la complejidad temporal del algoritmo resultante para computar $f_R(n,h)$ en el inciso c) debe ser $O(N H)$ (y también estar justificada).


\begin{enumerate}[$1)$]

 \item (No se incluye un ejercicio de programación dinámica - Todas las personas que rinden este recuperatorio tienen el tema aprobado)

 \item En un nuevo episodio de la la Guerra contra los Anuros, Francisco continúa sus preparativos para la red de computadoras $S$ de la facultad ante un posible sabotaje. La red, formada por un conjunto $C$ de cables bidireccionales, incluye una \emph{computadora central} $s_c \in S$ que provee internet a las demás. Sabemos que la red está dispuesta de tal forma que actualmente toda computadora de $S$ tiene conexión a internet, es decir, puede conectarse a $s_c$ por medio de una secuencia de cables. En $S$ también está la computadora $s_f$ de Francisco, además de un conjunto de computadoras $A \subseteq S$ que pertenecen a sus amigos. Los \emph{Anuros}, es decir, los anfibios que habitan Ciudad Universitaria, piensan cortar exactamente un cable de $C$, desconocemos cuál.

 \begin{enumerate}[$a)$]
     \item Los mejores amigos de Francisco son Aldo, Betty y Diana, cuyas computadoras son $s_a$, $s_b$ y $s_d$ respectivamente. Francisco está preocupado que luego del corte del cable \emph{alguno} de ellos se quede sin conexión a Internet (Francisco está pensando sólo en sus amistades y no le importa si él mismo se puede quedar sin conexión, sólo la posibilidad que alguien de sus 3 amigos lo haga). Dar un algoritmo de complejidad $O(|C|)$ que determine si es posible que por medio del corte de un cable se pueda dejar sin conexión a internet a alguno (o a más de uno) de $s_a$, $s_b$ o $s_d$. Justificar su correctitud y complejidad.
\end{enumerate}

Los Anuros, al saber de la planificación que está haciendo Francisco para reducir el impacto del sabotaje han decidido que en efecto cortarán el cable que maximice la cantidad de amigos de Francisco (es decir, computadoras en $A$) que se queden sin conexión a Internet.


\begin{enumerate}[$1)$]
 \item 

 \textit{"Porque yo soy tu turrito\\
Y yo sé que quieres ser mi turrita\\
Eres justito lo que necesito\\
Yo no andaba buscando una angelita y tú eres una diablita\\
Que se está portando mal, serás castigada..."\\}

    En el contexto de un proyecto de vinculación entre la academia y la industria (de la música en este caso) somos responsables de idear el nuevo hit de la música urbana. Para esto nos van a dar una lista $A_1,...,A_n$ de palabras que vamos a usar en ese orden. Nuestro trabajo es decidir cómo se particiona la lista de palabras en versos (un verso es un intervalo de palabras consecutivas). En el género evidentemente no tiene mucha importancia lo que las palabras dicen, así que no es necesario tener en cuenta dónde empiezan/terminan las frases/oraciones para separar. Sí es (muy) importante que rime y limitar la cantidad de palabras por verso. Hay dos restricciones:

    \begin{itemize}
        \item Vamos a usar rima pareada. Es decir, la última palabra del primer verso debe rimar con la última del segundo, la del tercer verso con la del cuarto, y así. La cantidad de versos debe ser par.
        \item Nuestro cantante tiene talento $c$: es capaz de cantar hasta $c$ palabras por verso. Por ende, la cantidad de palabras por verso deberá ser mayor a 0 y a lo sumo $c$.\footnote{El valor $c$ es parte del input, no una constante.}
    \end{itemize}

    Para hacer que rimen dos palabras que en principio no riman podemos utilizar un ``recurso'' que consiste en agregarle la terminación ``-ito''/``-ita'' a una o ambas palabras. Sin embargo, no podemos abusar de esto, porque le produce \emph{cringe} al público. Definimos el \emph{cringe} de la separación en versos como la cantidad de veces que se utiliza el ``recurso''. 
    
    Queremos calcular el mínimo \emph{cringe} que puede lograr una canción generada a partir de la lista de palabras $A_1, \ldots, A_n$ teniendo en cuenta que la va a cantar un cantante de talento $c$.

    Pueden asumir que tienen programada una función \textit{se\_puede\_armar\_rima} que dados dos índices $i,j$ tales que $1 \leq i < j \leq n$ y el valor $c$ decide si el intervalo cerrado $A_i,...,A_j$ se puede separar en dos versos válidos que rimen sin modificar palabras. La complejidad de esta función es lineal en el tamaño del intervalo.
  

\begin{enumerate}[$1)$]
  \item
  Nuevamente tenemos que idear un hit de la música urbana. Nuevamente nos van a dar una lista ordenada de $n$ palabras que debemos usar en ese orden, y las vamos a particionar en versos\footnote{Los versos son un intervalo de palabras consecutivas y todas las palabras deben pertenecer a un único verso}. Nuevamente queremos minimizar el \emph{cringe} de la canción resultante, que va a ser la sumatoria del \emph{cringe} de los versos. Esta vez el \emph{cringe} de cada verso va a ser una función que depende de cuántas palabras contenga el verso: llamamos $c_i$ al \emph{cringe} generado por un verso de $i$ palabras.

  \textbf{Ejemplo:} si nos dan $n = 5$ palabras (\textit{el,recu,no,fue,fácil}) y tenemos los siguientes valores de \emph{cringe} por longitud de verso

      \begin{center}
        \begin{tabular}{|c c c c c|}
            \hline
          $c_1$ & $c_2$ & $c_3$ & $c_4$ & $c_5$ \\
          \hline
          2 & 3 & 2 & 6 & 12\\
          \hline
      \end{tabular}
      \end{center}

hacer que sea todo un único verso tiene un \emph{cringe} de $c_5 = 12$. Partir en 5 versos de una única palabra cada uno es sumar $c_1$ cinco veces por lo tanto el cringe total es $5*c_1=10$. Ninguna de estas opciones es óptima ya que el mínimo \emph{cringe} alcanzable es 5, y hay dos maneras de lograrlo:

\begin{itemize}
    \item \textit{el recu} \hspace{7mm} ($c_2$ = 3)\\ \textit{no fue fácil.} ($c_3$ = 2)
    \item \textit{el recu no} \hspace{2mm}  ($c_3$ = 2) \\ \textit{fue fácil. } \hspace{2.5mm} ($c_2$ = 3)
\end{itemize}

\textbf{Input del problema:} la cantidad de palabras $n$ y valores enteros $c_1,...,c_n$ indicando el \emph{cringe} generado por cada longitud de verso.

 \begin{enumerate}[$a)$]
  \item Definir en forma recursiva la funcion $f \colon \mathbb{N} \to \mathbb{N}$ tal que $f(i)$ devuelve el mínimo valor de \emph{cringe} alcanzable para una lista de $i$ palabras. Indicar qué llamado(s) hay que hacer a esta función para resolver el problema. \textbf{Importantísimo:} acompañen a la definición recursiva con una explicación en castellano.

  \item Demostrar que $f$ tiene la propiedad de superposición de subproblemas.

  \item Definir un algoritmo \textit{top-down} para calcular $f(i)$ indicando claramente las estructuras de datos utilizadas y la complejidad resultante.

  \item Escribir el (pseudo-)código del algoritmo top-down resultante.
 \end{enumerate}
%  \textbf{Aprobación:} definir y justificar correctamente $f$, indicando cómo se computa $f(i,v,k,uno)$ en tiempo $O(i\min\{v,i\}\min\{k,i\})$.
 \textbf{Criterio de aprobación:} La función recursiva debe ser correcta y la complejidad temporal del algoritmo final basado en programación dinámica para computar $f(n)$ ser $O(n^2)$.
 

./exercises/CacheOffline.txt

\item Como los accesos a memoria RAM son lentos en comparación al trabajo propio del CPU, es común que se coloquen memorias intermedias más diminutas y de alta velocidad entre ambas unidades, las cuales llamamos \textit{cachés}. Cuando un programa se ejecuta y hace una consulta a la memoria por cierta posición $r$ primero se verifica si la posición $r$ está cargada en la caché, en cuyo caso el CPU la puede obtener sin tener que hacer el acceso a la RAM. Cuando esto ocurre, decimos que ocurre un \textit{caché hit}. En cambio, si la posición $r$ no está en la caché, esta se busca a memoria, se carga en la caché, y luego se la informa al CPU. A este evento se lo conoce como \textit{caché miss}.

Como la caché es más chica que la memoria RAM es inevitable que eventualmente ocurra un \textit{caché miss} y que la caché este llena. En ese caso, la caché debe decidir qué información va a desechar para darle lugar a la nueva entrada. Naturalmente, se busca minimizar la cantidad de \textit{misses} de los siguientes accesos.

El problema de \textit{Off-line} caching consiste en determinar, dada una caché $C$ de tamaño $k$ y una lista de $n$ requests $R = \{r_1, r_2, \ldots, r_n\}$\footnote{Sin pérdida de generalidad respecto al problema, podemos asumir que $1 \leq r_i \leq n$ para todo $i$.} a posiciones de memoria, qué decisión debe tomar en cada paso la caché para minimizar la cantidad de \textit{misses}. Por ejemplo, si $k=2$ y $R=\{1,2,3,1\}$ entonces:

\begin{itemize}
    \item La primera consulta es un \textit{miss}, pero como hay lugar en la caché (empieza vacía) se carga la posición 1 a $C$ ($C= \{1\}$).
    \item Con la segunda consulta pasa lo mismo, por lo que la caché queda en el estado $C= \{1, 2\}$.
    \item En la tercera consulta la caché esta llena, por lo que se debe desechar alguna entrada. Notemos que si se desecha $1$ entonces la cuarta consulta dará otro \textit{miss}, mientras que si se desecha $2$ entonces habrá un \textit{hit}.
\end{itemize}

Una política posible para decidir qué elemento desachar es la \textit{furthest-in-future}: se desecha aquella posición $r$ cuyo siguiente acceso es el más lejano (o bien, que no tiene un siguiente acceso). 

\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
    \item \textbf{Opcional}: Definir una función recursiva $f(i, mem)$ que tome un índice y un estado de la memoria y devuelva la mínima cantidad de \textit{caché misses} que deben ocurrir para procesar todas las consultas $\{r_i, r_{i+1}, \ldots, r_n\}$ si el estado actual de la memoria es $mem$ ¿Con qué llamado se resuelve el problema? Estudiar la superposición de subproblemas y explicar en qué casos vale la pena memorizar.
    
    \item Probar que la política \textit{furthest-in-future} es óptima (es decir, que minimiza la cantidad de \textit{misses}). \textbf{Ayuda}: Dada una serie de decisiones, probar que si en un paso no se sigue la política \textit{furthest} entonces podemos alterar ese paso para que sí la siga sin afectar la cantidad de \textit{misses}. 
    \item Dar un algoritmo con complejidad temporal $O(n \log (k))$ que informe qué decisión debe tomar la caché en cada paso para minimizar la cantidad de \textit{misses}.
\end{enumerate}



./exercises/ParejasdeBaile_bmarkEvaluador.txt

Para resolver el problema de formar las parejas de baile con la menor diferencia de habilidad posible, primero pensé en usar un algoritmo de ordenamiento, pero luego recordé que los conjuntos ya están ordenados. Entonces, lo que hice fue un algoritmo que recorre ambos conjuntos al mismo tiempo, comparando las habilidades de baile una por una.

Inicialmente, puse dos punteros, uno para cada conjunto, al inicio de los mismos. Después, mientras ambos punteros tienen elementos para comparar, hago lo siguiente: si la diferencia de habilidad entre los dos punteros es de 1 o menos, formo una pareja y muevo ambos punteros al siguiente elemento. Si la diferencia es mayor que 1, muevo el puntero del conjunto con la habilidad menor hacia adelante, esperando encontrar una mejor coincidencia.

El código es algo así:

```python
def formar_parejas(conjunto1, conjunto2):
    i, j = 0, 0
    parejas = 0
    while i < len(conjunto1) and j < len(conjunto2):
        if abs(conjunto1[i] - conjunto2[j]) <= 1:
            parejas += 1
            i += 1
            j += 1
        elif conjunto1[i] < conjunto2[j]:
            i += 1
        else:
            j += 1
    return parejas
```

Creo que la complejidad temporal de mi algoritmo es O(n+m) porque en el peor de los casos tengo que recorrer ambos conjuntos una vez, siendo n y m la longitud de cada conjunto. La complejidad espacial es O(1), ya que solo utilizo variables para los índices y el contador de parejas.

No estoy muy seguro de cómo demostrar formalmente que el algoritmo es correcto, pero creo que funciona porque siempre busco la pareja más cercana en habilidad para cada persona y no repito personas en las parejas.

./exercises/SumadeSubconjuntos.txt

\item En este ejercicio vamos a resolver el problema de suma de subconjuntos con la técnica de \textit{backtracking}.  Dado un multiconjunto $C = \{c_1, \ldots, c_n\}$ de números naturales y un natural $k$, queremos determinar si existe un subconjunto de $C$ cuya sumatoria sea $k$.  Vamos a suponer fuertemente que $C$ está ordenado de alguna forma arbitraria pero conocida (i.e., $C$ está implementado como la secuencia $c_1, \ldots, c_n$ o, análogamente, tenemos un iterador de $C$).  Las \emph{soluciones (candidatas)} son los vectores $a = (a_1, \ldots, a_n)$ de valores binarios; el subconjunto de $C$ representado por $a$ contiene a $c_i$ si y sólo si $a_i = 1$.  Luego, $a$ es una solución \emph{válida} cuando $\sum_{i=1}^n a_i c_i = k$.  Asimismo, una \emph{solución parcial} es un vector $p = (a_1, \ldots, a_i)$ de números binarios con $0 \leq i \leq n$.  Si $i < n$, las soluciones \emph{sucesoras} de $p$ son $p \oplus 0$ y $p \oplus 1$, donde $\oplus$ indica la concatenación.
\label{ejercicioSumaDeSubconjuntos}

\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
 \item Escribir el conjunto de soluciones candidatas para $C = \{6, 12, 6\}$ y $k = 12$.
 \item Escribir el conjunto de soluciones válidas para $C = \{6, 12, 6\}$ y $k = 12$.
 \item Escribir el conjunto de soluciones parciales para $C = \{6, 12, 6\}$ y $k = 12$.
 \item Dibujar el árbol de \textit{backtracking} correspondiente al algoritmo descrito arriba para $C = \{6, 12, 6\}$ y $k = 12$, indicando claramente la relación entre las distintas componentes del árbol y los conjuntos de los incisos anteriores.
 \item Sea $\mathcal{C}$ la familia de todos los multiconjuntos de números naturales.  Considerar la siguiente función recursiva $\SubsetSum \colon \mathcal{C} \times \mathbb{N} \to \{V,F\}$ (donde $\mathbb{N} = \{ 0, 1, 2, \dots \}$, $V$ indica verdadero y $F$ falso):
 \begin{displaymath}
  \SubsetSum(\{c_1, \ldots, c_n\}, k) = \begin{cases}
   k = 0 & \text{si $n = 0$} \\
   \SubsetSum(\{c_1, \ldots, c_{n-1}\}, k) \lor \SubsetSum(\{c_1, \ldots, c_{n-1}\}, k - c_n) & \text{si $n > 0$}
  \end{cases}
 \end{displaymath}
 Convencerse de que $\SubsetSum(C, k) = V$ si y sólo si el problema de subconjuntos tiene una solución válida para la entrada $C, k$.  Para ello, observar que hay dos posibilidades para una solución válida $a = (a_1, \ldots, a_n)$ para el caso $n > 0$: o bien $a_n = 0$ o bien $a_n = 1$.  En el primer caso, existe un subconjunto de $\{c_1, \ldots, c_{n-1}\}$ que suma $k$; en el segundo, existe un subconjunto de $\{c_1, \ldots, c_{n-1}\}$ que suma $k - c_n$.
 \label{sumaDeSubconjuntosFormRecBT}
 \item Convencerse de que la siguiente es una implementación recursiva de $\SubsetSum$ en un lenguaje imperativo y de que retorna la solución para $C, k$ cuando se llama con $C, |C|, k$. ¿Cuál es su complejidad?
 \label{sumaDeSubconjuntosAlgoBT}

 \begin{enumerate}
  \item $\SubsetSumAlg(C, i, j)$: // implementa $\SubsetSum(\{c_1, \ldots, c_i\}, j)$
  \item ~~~~Si $i = 0$, retornar $(j = 0)$
  \item ~~~~Si no, retornar $\SubsetSumAlg(C, i-1, j) \lor \SubsetSumAlg(C, i-1, j - C[i])$
 \end{enumerate}

 \item Dibujar el árbol de llamadas recursivas para la entrada $C = \{6, 12, 6\}$ y $k = 12$, y compararlo con el árbol de \textit{backtracking}.
 \item Considerar la siguiente \emph{regla de factibilidad}: $p = (a_1, \ldots, a_i)$ se puede extender a una solución válida sólo si $\sum_{q=1}^i a_q c_q \leq k$.  Convencerse de que la siguiente implementación incluye la regla de factibilidad.

  \begin{enumerate}
  \item $\SubsetSumAlg(C, i, j)$: // implementa $\SubsetSum(\{c_1, \ldots, c_i\}, j)$
  \item ~~~~Si $j < 0$, retornar \textbf{falso} // regla de factibilidad
  \item ~~~~Si $i = 0$, retornar $(j = 0)$
  \item ~~~~Si no, retornar $\SubsetSumAlg(C, i-1, j) \lor \SubsetSumAlg(C, i-1, j - C[i])$
 \end{enumerate}

 \item Definir otra regla de factibilidad, mostrando que la misma es correcta; no es necesario implementarla.
 \item Modificar la implementación para imprimir el subconjunto de $C$ que suma $k$, si existe. \textbf{Ayuda:} mantenga un vector con la solución parcial $p$ al que se le agregan y sacan los elementos en cada llamada recursiva; tenga en cuenta de no suponer que este vector se copia en cada llamada recursiva, porque cambia la complejidad.
\end{enumerate}

./exercises/ApilamientodeCajas.txt
\item Tenemos cajas numeradas de $1$ a $N$, todas de iguales dimensiones. Queremos encontrar la máxima cantidad de cajas que pueden apilarse en una única pila cumpliendo que:
\begin{itemize}
\item sólo puede haber una caja apoyada directamente sobre otra;
\item las cajas de la pila deben estar ordenadas crecientemente por número, de abajo para arriba;
\item cada caja $i$ tiene un peso $w_i$ y un soporte $s_i$, y el peso total de las cajas que están arriba de otra no debe exceder el soporte de esa otra.
\end{itemize}
\par{Si tenemos los pesos $w = [19, 7, 5, 6, 1]$ y los soportes $s = [15, 13, 7, 8, 2]$ (la caja 1 tiene peso 19 y soporte 15, la caja 2 tiene peso 7 y soporte 13, etc.), entonces la respuesta es 4. Por ejemplo, pueden apilarse de la forma 1-2-3-5 o 1-2-4-5 (donde la izquierda es más abajo), entre otras opciones.}

\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
\item Pensar la idea de un algoritmo de \textit{backtracking} (no hace falta escribirlo).
\item Escribir una formulación recursiva que sea la base de un algoritmo de PD. Explicar su semántica e indicar cuáles serían los parámetros para resolver el problema.
\item Diseñar un algoritmo de PD y dar su complejidad temporal y espacial auxiliar. Comparar cómo resultaría un enfoque \textit{top-down} con uno \textit{bottom-up}.
\item (Opcional) Formalizar el problema y demostrar que la función recursiva es correcta.
\end{enumerate}
./exercises/SubconjuntosyPermutaciones.txt
\item Dada una matriz simétrica $M$ de $n \times n$ números naturales y un número $k$, queremos encontrar un subconjunto $I$ de $\{1, \ldots, n\}$ con $|I| = k$ que maximice $\sum_{i,j \in I} M_{ij}$.  Por ejemplo, si $k = 3$ y:
\begin{displaymath}
    M = \begin{pmatrix}
          0 & 10 & 10 & 1 \\
          - &  0 &  5 & 2 \\
          - &  - &  0 & 1 \\
          - &  - &  - & 0
        \end{pmatrix},
\end{displaymath}
entonces $I = \{1,2,3\}$ es una solución óptima.


\begin{enumerate}
 \item Diseñar un algoritmo de \emph{backtracking} para resolver el problema, indicando claramente cómo se codifica una solución candidata, cuáles soluciones son válidas y qué valor tienen, qué es una solución parcial y cómo se extiende cada solución parcial.
 \item Calcular la complejidad temporal y espacial del mismo.
 \item Proponer una poda por optimalidad y mostrar que es correcta.
\end{enumerate}

\item Dada una matriz $D$ de $n \times n$ números naturales, queremos encontrar una permutación $\pi$\footnote{Una permutacion de un conjunto finito $X$ es simplemente una función biyectiva de $X$ en $X$.} de $\{1, \ldots, n\}$ que minimice $D_{\pi(n)\pi(1)} + \sum_{i=1}^{n-1} D_{\pi(i)\pi(i+1)}$.  Por ejemplo, si
\begin{displaymath}
    D = \begin{pmatrix}
          0  &  1 & 10 & 10 \\
          10 &  0 &  3 & 15 \\
          21 &  17 &  0 & 2 \\
           3 &  22 & 30 & 0
        \end{pmatrix},
\end{displaymath}
entonces $\pi(i) = i$ es una solución optima.

\begin{enumerate}
 \item Diseñar un algoritmo de \emph{backtracking} para resolver el problema, indicando claramente cómo se codifica una solución candidata, cuáles soluciones son válidas y qué valor tienen, qué es una solución parcial y cómo se extiende cada solución parcial.
 \item Calcular la complejidad temporal y espacial del mismo.
 \item Proponer una poda por optimalidad y mostrar que es correcta.
\end{enumerate}
./exercises/MaximizarMex.txt
\item Se define la función $mex: \mathcal{P}(\mathds{N}) \to \mathds{N}$ como

$$
mex(X) = \min\{j : j\in \mathds{N} \wedge j \notin X\}
$$

Intuitivamente, $mex$ devuelve, dado un conjunto $X$, el menor número natural que no está en $x$. Por ejemplo, $mex(\{0,1,2\}) = 3$, $mex(\{0, 1, 3\}) = 2$ y $mex(\{1,2,3, \ldots\}) = 0$.

Dado un vector de número $a_1 \ldots a_n$ queremos encontrar la permutación $b_1 \ldots b_n$ de los mismos que maximize

$$
\sum_{i=1}^n mex(\{b_1 \ldots b_i\})
$$

Por ejemplo, si el vector es $\{3, 0, 1\}$ podemos ver que la mejor permutación es $\{0, 1, 3\}$, que alcanza un valor de

$$
mex(\{0\}) + mex(\{0, 1\}) + mex(\{0,1,3\}) = 1+2+2 = 5
$$

\begin{enumerate}
    \item Proponer un algoritmo \textit{greedy} que resuelva el problema y demostrar su correctitud. \textbf{Ayuda}: ¿Cuál el máximo valor que puede tomar $mex(X)$ si $X$ tiene $n$ elementos? Si $X \subseteq Y$, ¿Qué pasa con los valores $mex(X)$ y $mex(Y)$?

    \item Dar una implementación del algoritmo del inciso anterior con complejidad temporal $O(n)$.
\end{enumerate}
./exercises/Billetes.txt
\item Tenemos un multiconjunto $B$ de valores de billetes y queremos comprar un producto de costo $c$ de una máquina que no da vuelto.  Para poder adquirir el producto debemos cubrir su costo usando un subconjunto de nuestros billetes. El objetivo es pagar con el mínimo exceso posible a fin de minimizar nuestra pérdida.  Más aún, queremos gastar el menor tiempo posible poniendo billetes en la máquina. Por lo tanto, entre las opciones de mínimo exceso posible, queremos una con la menor cantidad de billetes. Por ejemplo, si $c = 14$ y $B = \{2, 3, 5, 10, 20, 20\}$, la solución es pagar 15, con exceso $1$, insertando sólo dos billetes: uno de 10 y otro de 5.

\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
 \item Considerar la siguiente estrategia por \textit{backtracking} para el problema, donde $B = \{b_1, \ldots, b_n\}$. Tenemos dos posibilidades: o agregamos el billete $b_n$, gastando un billete y quedando por pagar $c-b_n$, o no agregamos el billete $b_n$, gastando $0$ billetes y quedando por pagar $c$.  Escribir una función recursiva $\Vuelto(B, c)$ para resolver el problema, donde $\Vuelto(B, c) = (c', q)$ cuando el mínimo costo mayor o igual a $c$ que es posible pagar con los billetes de $B$ es $c'$ y la cantidad de billetes mínima es $q$.
\label{billetesFormRec}

 \item Implementar la función de \ref{billetesFormRec} en un lenguaje de programación imperativo utilizando una función recursiva con parámetros $B$, $i$, $j$ que compute $\Vuelto(\{b_1, \ldots, b_i\}, j)$.  ¿Cuál es la complejidad del algoritmo?
 \label{billetesAlgoBT}

 \item Reescribir $\Vuelto$ como una función recursiva $\VueltoPD_B(i, j) = \Vuelto(\{b_1, \ldots, b_i\}, j)$ que implemente la idea anterior \textbf{dejando fijo el parámetro $B$}.  A partir de esta función, determinar cuándo $\VueltoPD_B$ tiene la propiedad de \emph{superposición de subproblemas}.

 \item Definir una estructura de memoización para $\VueltoPD_B$ que permita acceder a $\VueltoPD_B(i, j)$ en $\mathcal{O}(1)$ tiempo para todo $0 \leq i \leq n$ y $0 \leq j \leq k$.

 \item Adaptar el algoritmo de \ref{billetesAlgoBT} para incluir la estructura de memoización.

 \item Indicar cuál es la llamada recursiva que resuelve nuestro problema y cuál es la complejidad del nuevo algoritmo.

 \item (Opcional) Escribir un algoritmo \emph{bottom-up} para calcular todos los valores de la estructura de memoización y discutir cómo se puede reducir la memoria extra consumida por el algoritmo.

 \item (Opcional) Formalmente, en este problema de vuelto hay que computar el mínimo $(\sum V, |V|)$, en orden lexicográfico, de entre los conjuntos $V \subseteq B$ tales que $\sum V \geq c$.  Demostrar que la función $\VueltoPD$ es correcta.  \textbf{Ayuda:} demostrar por inducción que $\VueltoPD(i,j) = (v,k)$ para el mínimo $(v,k)$ tal que existe un subconjunto $V$ de $\{b_1, \ldots, b_i\}$ con $\sum_V \geq j$.

\end{enumerate}

./exercises/IntercalarOperaciones.txt
\item Sea $v=(v_1, v_2, \ldots v_n)$ un vector de n\'umeros naturales, y sea $w \in \mathbb{N}$.
Se desea intercalar entre los elementos de $v$ las operaciones $+$ (suma), $\times$ (multiplicaci\'on) y $\uparrow$ (potenciaci\'on) de tal manera que al evaluar la expresi\'on obtenida el resultado sea $w$.
Para evaluar la expresi\'on se opera de izquierda a derecha ignorando la precedencia de los operadores.
Por ejemplo, si $v=(3, 1, 5, 2, 1)$, y las operaciones elegidas son $+$, $\times$, $\uparrow$ y $\times$ (en ese orden), la expresi\'on obtenida es $3 + 1 \times 5 \uparrow 2 \times 1$, que se evalúa como $(((3 + 1) \times 5) \uparrow 2) \times 1 = 400$.
\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
\item Escribir una formulación recursiva que sea la base de un algoritmo de PD que, dados $v$ y $w$, encuentre una secuencia de operaciones como la deseada, en caso de que tal secuencia exista. Explicar su semántica e indicar cuáles serían los parámetros para resolver el problema.
\label{operacionesFormRec}
\item Dise\~nar un algoritmo basado en PD con la formulación de \ref{operacionesFormRec} y dar su complejidad temporal y espacial auxiliar. Comparar cómo resultaría un enfoque \textit{top-down} con uno \textit{bottom-up}.
\item (Opcional) Formalizar el problema y demostrar que la función recursiva es correcta.
\end{enumerate}
./exercises/MaximoValordeSubconjuntodeTamanok.txt
\item Dado un conjunto $X$ con $|X| = n$ y un entero $k\leq n$ queremos encontrar el máximo valor que pueden sumar los elementos de un subconjunto $S$ de $X$ de tamaño $k$. Más formalmente, queremos calcular $\max\limits_{S \subseteq X, |S| = k} \sum_{s \in S} s$.

\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
    \item Proponer un algoritmo \textit{greedy} que resuelva el problema, demostrando su correctitud. Extender el algoritmo para que también devuelva uno de los subconjuntos $S$ que maximiza la suma.\label{sumaIdea}
    \item Dar una implementación del algoritmo del inciso \ref{sumaIdea} con complejidad temporal $O(n\log n)$.

    \item Dar una implementación del algoritmo del inciso \ref{sumaIdea} con complejidad temporal $O(n \log k)$.
\end{enumerate}
./exercises/SumadeElementosconCostoMínimo.txt
\item Queremos encontrar la suma de los elementos de un multiconjunto de números naturales. Cada suma se realiza exactamente entre dos números $x$ e $y$ y tiene costo $x + y$.
\par{Por ejemplo, si queremos encontrar la suma de $\{ 1, 2, 5 \}$ tenemos 3 opciones:}
\begin{itemize}
\item 1 + 2 (con costo 3) y luego 3 + 5 (con costo 8), resultando en un costo total de 11;
\item 1 + 5 (con costo 6) y luego 6 + 2 (con costo 8), resultando en un costo total de 14;
\item 2 + 5 (con costo 7) y luego 7 + 1 (con costo 8), resultando en un costo total de 15.
\end{itemize}
\par{Queremos encontrar la forma de sumar que tenga costo mínimo, por lo que en nuestro ejemplo la mejor forma sería la primera.}

\begin{enumerate}
 \item Explicitar una estrategia golosa para resolver el problema.
 \item Demostrar que la estrategia propuesta resuelve el problema.
 \item Implementar esta estrategia en un algoritmo iterativo.  \textbf{Nota:} el mejor algoritmo simple que conocemos tiene complejidad $\mathcal{O}(n\log n)$ y utiliza una estructura de datos que implementa una secuencia ordenada.
\end{enumerate}
./exercises/CuadradoMagico.txt


\item Un \emph{cuadrado mágico de orden $n$}, es un cuadrado con los números $\{1, \ldots, n^2\}$, tal que todas sus filas, columnas y las dos diagonales suman lo mismo (ver figura).  El número que suma cada fila es llamado \emph{número mágico}.

 \begin{center}
  \begin{tabular}{|c|c|c|}
   \hline
   2 & 7 & 6 \\ \hline
   9 & 5 & 1 \\ \hline
   4 & 3 & 8 \\ \hline
  \end{tabular}
 \end{center}

 Existen muchos métodos para generar cuadrados mágicos.  El objetivo de este ejercicio es contar cuántos cuadrados mágicos de orden $n$ existen.

 \begin{enumerate}
  \item ¿Cuántos cuadrados habría que generar para encontrar todos los cuadrados mágicos si se utiliza una solución de fuerza bruta?
  \item Enunciar un algoritmo que use \textit{backtracking} para resolver este problema que se base en la siguientes ideas:

  \begin{itemize}
   \item La solución parcial tiene los valores de las primeras $i-1$ filas establecidos, al igual que los valores de las primeras $j$ columnas de la fila $i$.
   \item Para establecer el valor de la posición $(i,j+1)$ (o $(i+1,1)$ si $j = n$ e $i \neq n$) se consideran todos los valores que aún no se encuentran en el cuadrado.  Para cada valor posible, se establece dicho valor en la posición y se cuentan todos los cuadrados mágicos con esta nueva solución parcial.
  \end{itemize}

  Mostrar los primeros dos niveles del árbol de \textit{backtracking} para $n = 3$.

  \item Demostrar que el árbol de \textit{backtracking} tiene $\mathcal{O}((n^2)!)$ nodos en peor caso.
  \item\label{ej:magico:it:back} Considere la siguiente poda al árbol de \textit{backtracking}: al momento de elegir el valor de una nueva posición, verificar que la suma parcial de la fila no supere el número mágico.  Verificar también que la suma parcial de los valores de las columnas no supere el número mágico. Introducir estas podas al algoritmo e implementarlo en la computadora.  ¿Puede mejorar estas podas?
  \item\label{ej:magico:it:back2} Demostrar que el número mágico de un cuadrado mágico de orden $n$ es siempre $(n^3 + n)/2$. Adaptar la poda del algoritmo del ítem anterior para que tenga en cuenta esta nueva información.  Modificar la implementación y comparar los tiempos obtenidos para calcular la cantidad de cuadrados mágicos.
 \end{enumerate}

./exercises/Astrovoid.txt
\item Astro Void se dedica a la compra de asteroides. Sea $p \in \mathbb{N}^n$ tal que $p_i$ es el precio de un asteroide el $i$-ésimo día en una secuencia de $n$ días. Astro Void quiere comprar y vender asteroides durante esos $n$ días de manera tal de obtener la mayor ganancia neta posible. Debido a las dificultades que existen en el transporte y almacenamiento de asteroides, Astro Void puede comprar a lo sumo un asteroide cada día, puede vender a lo sumo un asteroide cada día y comienza sin asteroides. Además, el Ente Regulador Asteroidal impide que Astro Void venda un asteroide que no haya comprado. Queremos encontrar la máxima ganancia neta que puede obtener Astro Void respetando las restricciones indicadas. Por ejemplo, si $p = (3, 2, 5, 6)$ el resultado es $6$ y si $p = (3,6,10)$ el resultado es $7$.  Notar que en una solución óptima, Astro Void debe terminar sin asteroides.
\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
\item Convencerse de que la máxima ganancia neta (m.g.n.), si Astro Void tiene $c$ asteroides al fin del día $j$, es:
\begin{itemize}
 \item indefinido (i.e., $-\infty$) si $c < 0$ o $c > j$, o
 \item el máximo entre:
 \begin{itemize}
  \item la m.g.n. de finalizar el día $j-1$ con $c-1$ asteroides y comprar uno en el día $j$,
  \item la m.g.n. de finalizar el día $j-1$ con $c+1$ asteroides y vender uno en el día $j$,
  \item la m.g.n. de finalizar el día $j-1$ con $c$ asteroides y no operar el día $j$.
 \end{itemize}
\end{itemize}
\label{AstroFormRec}

\item Escribir matemáticamente la formulación recursiva enunciada en \ref{AstroFormRec}. Dar los valores de los casos base en función de la restricción de que comienza sin asteroides.
\item Indicar qué dato es la respuesta al problema con esa formulación recursiva.
\item Diseñar un algoritmo de PD \emph{top-down} que resuelva el problema y explicar su complejidad temporal y espacial auxiliar.
\item (Opcional) Diseñar un algoritmo de PD \emph{bottom-up}, reduciendo la complejidad espacial.
\item (Opcional) Formalmente, el problema consiste en determinar el máximo $g = \sum_{i=1}^n x_i p_i$ para un vector $x = (x_1, \ldots, x_n)$ tal que: $x_i \in \{-1,0,1\}$ para todo $1 \leq i \leq n$ y $\sum_{i=1}^j x_i \geq 0$ para todo $1 \leq j \leq n$.  Demostrar que la formulacion recursiva es correcta. \textbf{Ayuda}: primero demostrar que existe una solución óptima en la que Astro Void se queda sin asteroides en el día $n$.  Luego, demostrar por inducción que la función recursiva respeta la semántica, i.e., que computa la m.g.n.\ al final del día $j$ cuando Astro Void posee $c$ asteroides.
\end{enumerate}
./exercises/test.txt

\item En este ejercicio vamos a resolver el problema de suma de subconjuntos con la técnica de \textit{backtracking}.  Dado un multiconjunto $C = \{c_1, \ldots, c_n\}$ de números naturales y un natural $k$, queremos determinar si existe un subconjunto de $C$ cuya sumatoria sea $k$.  Vamos a suponer fuertemente que $C$ está ordenado de alguna forma arbitraria pero conocida (i.e., $C$ está implementado como la secuencia $c_1, \ldots, c_n$ o, análogamente, tenemos un iterador de $C$).  Las \emph{soluciones (candidatas)} son los vectores $a = (a_1, \ldots, a_n)$ de valores binarios; el subconjunto de $C$ representado por $a$ contiene a $c_i$ si y sólo si $a_i = 1$.  Luego, $a$ es una solución \emph{válida} cuando $\sum_{i=1}^n a_i c_i = k$.  Asimismo, una \emph{solución parcial} es un vector $p = (a_1, \ldots, a_i)$ de números binarios con $0 \leq i \leq n$.  Si $i < n$, las soluciones \emph{sucesoras} de $p$ son $p \oplus 0$ y $p \oplus 1$, donde $\oplus$ indica la concatenación.
\label{ejercicioSumaDeSubconjuntos}

\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
 \item Escribir el conjunto de soluciones candidatas para $C = \{6, 12, 6\}$ y $k = 12$.
 \item Escribir el conjunto de soluciones válidas para $C = \{6, 12, 6\}$ y $k = 12$.
 \item Escribir el conjunto de soluciones parciales para $C = \{6, 12, 6\}$ y $k = 12$.
 \item Dibujar el árbol de \textit{backtracking} correspondiente al algoritmo descrito arriba para $C = \{6, 12, 6\}$ y $k = 12$, indicando claramente la relación entre las distintas componentes del árbol y los conjuntos de los incisos anteriores.
 \item Sea $\mathcal{C}$ la familia de todos los multiconjuntos de números naturales.  Considerar la siguiente función recursiva $\SubsetSum \colon \mathcal{C} \times \mathbb{N} \to \{V,F\}$ (donde $\mathbb{N} = \{ 0, 1, 2, \dots \}$, $V$ indica verdadero y $F$ falso):
 \begin{displaymath}
  \SubsetSum(\{c_1, \ldots, c_n\}, k) = \begin{cases}
   k = 0 & \text{si $n = 0$} \\
   \SubsetSum(\{c_1, \ldots, c_{n-1}\}, k) \lor \SubsetSum(\{c_1, \ldots, c_{n-1}\}, k - c_n) & \text{si $n > 0$}
  \end{cases}
 \end{displaymath}
 Convencerse de que $\SubsetSum(C, k) = V$ si y sólo si el problema de subconjuntos tiene una solución válida para la entrada $C, k$.  Para ello, observar que hay dos posibilidades para una solución válida $a = (a_1, \ldots, a_n)$ para el caso $n > 0$: o bien $a_n = 0$ o bien $a_n = 1$.  En el primer caso, existe un subconjunto de $\{c_1, \ldots, c_{n-1}\}$ que suma $k$; en el segundo, existe un subconjunto de $\{c_1, \ldots, c_{n-1}\}$ que suma $k - c_n$.
 \label{sumaDeSubconjuntosFormRecBT}
 \item Convencerse de que la siguiente es una implementación recursiva de $\SubsetSum$ en un lenguaje imperativo y de que retorna la solución para $C, k$ cuando se llama con $C, |C|, k$. ¿Cuál es su complejidad?
 \label{sumaDeSubconjuntosAlgoBT}

 \begin{enumerate}
  \item $\SubsetSumAlg(C, i, j)$: // implementa $\SubsetSum(\{c_1, \ldots, c_i\}, j)$
  \item ~~~~Si $i = 0$, retornar $(j = 0)$
  \item ~~~~Si no, retornar $\SubsetSumAlg(C, i-1, j) \lor \SubsetSumAlg(C, i-1, j - C[i])$
 \end{enumerate}

 \item Dibujar el árbol de llamadas recursivas para la entrada $C = \{6, 12, 6\}$ y $k = 12$, y compararlo con el árbol de \textit{backtracking}.
 \item Considerar la siguiente \emph{regla de factibilidad}: $p = (a_1, \ldots, a_i)$ se puede extender a una solución válida sólo si $\sum_{q=1}^i a_q c_q \leq k$.  Convencerse de que la siguiente implementación incluye la regla de factibilidad.

  \begin{enumerate}
  \item $\SubsetSumAlg(C, i, j)$: // implementa $\SubsetSum(\{c_1, \ldots, c_i\}, j)$
  \item ~~~~Si $j < 0$, retornar \textbf{falso} // regla de factibilidad
  \item ~~~~Si $i = 0$, retornar $(j = 0)$
  \item ~~~~Si no, retornar $\SubsetSumAlg(C, i-1, j) \lor \SubsetSumAlg(C, i-1, j - C[i])$
 \end{enumerate}

 \item Definir otra regla de factibilidad, mostrando que la misma es correcta; no es necesario implementarla.
 \item Modificar la implementación para imprimir el subconjunto de $C$ que suma $k$, si existe. \textbf{Ayuda:} mantenga un vector con la solución parcial $p$ al que se le agregan y sacan los elementos en cada llamada recursiva; tenga en cuenta de no suponer que este vector se copia en cada llamada recursiva, porque cambia la complejidad.
\end{enumerate}

./exercises/SumadeSubconjuntos_bmarkEvaluador.txt
Lo siguiente es una respuesta simulada para usar de benchmark para comparar prompts evaluadores y de feedback.

---

**Conjunto de soluciones candidatas para C={6,12,6} y k=12:**

Las soluciones candidatas son todos los subconjuntos posibles que se pueden formar con los elementos de C, representados por vectores de valores binarios. Así, tenemos:
- (1,0,0)
- (0,1,0)
- (0,0,1)
- (1,1,0)
- (1,0,1)
- (0,1,1)
- (1,1,1)

Creo que estos representan todas las combinaciones posibles, pero no estoy seguro de si entendí correctamente la representación binaria.

**Conjunto de soluciones válidas para C={6,12,6} y k=12:**

Las soluciones válidas son aquellas cuya sumatoria de elementos seleccionados es igual a k. Por lo tanto, serían:
- (0,1,0) ya que 12=12
- (1,0,1) ya que 6+6=12

Puede que haya omitido algunas combinaciones, pero estas son las que encontré que suman 12.

**Conjunto de soluciones parciales para C={6,12,6} y k=12:**

Una solución parcial sería cualquier subconjunto del conjunto completo, por lo que:
- (1)
- (0)
- (1,0)
- (0,1)
- (1,1)

Estas son algunas de las soluciones parciales, aunque no estoy seguro de si la definición de soluciones parciales que utilicé es la correcta.

**Dibujo del árbol de backtracking:**

Aquí me quedé un poco confundido y no logré dibujar el árbol correctamente. Entiendo que debería mostrar cómo se van formando las soluciones y descartando las que no cumplen, pero no sé cómo representarlo para este caso.

**Función recursiva \SubsetSum y su implementación:**

Para \SubsetSum, entiendo que la función intenta encontrar si se puede formar un subconjunto que sume k partiendo de cualquier subconjunto de C. La implementación recursiva sería algo así en pseudocódigo:

```
SubsetSum(C, n, k):
    if k == 0:
        return Verdadero
    if n == 0:
        return Falso
    return SubsetSum(C, n-1, k) || SubsetSum(C, n-1, k - C[n])
```

Sobre la complejidad, creo que es O(2^n) porque en el peor de los casos, tendría que explorar todos los subconjuntos posibles.

**Árbol de llamadas recursivas vs. árbol de backtracking:**

No estoy muy seguro de cómo diferenciar claramente entre estos dos árboles en este contexto. Sé que ambos representan las decisiones tomadas en el proceso, pero me cuesta visualizar el árbol de llamadas recursivas para este problema específico.

**Regla de factibilidad en la implementación:**

La implementación con la regla de factibilidad que impide seguir si la suma parcial excede k me parece correcta. No sé cómo definir otra regla de factibilidad sin más contexto sobre qué otras condiciones podrían aplicarse para optimizar la búsqueda.

**Modificar la implementación para imprimir el subconjunto que suma k:**

Para esta parte, admito que me confundí un poco en cómo mantener el vector de solución parcial sin alterar la complejidad. Supongo que tendría que añadir y quitar elementos del vector en cada llamada recursiva, pero no estoy seguro de cómo hacerlo eficientemente.

---

Esta respuesta contiene varios puntos bien abordados, inconsistencias sutiles, y algunos errores claros, ideal para evaluar cómo el prompt evaluador proporcionaría retroalimentación constructiva y detallada.
./exercises/ProblemadelaFiesta.txt
\item\label{ej:ind set} El problema de la fiesta consiste en determinar un conjunto de invitados que no tengan conflictos entre sí y que sea de cardinalidad máxima.  Formalmente, dado un conjunto $V$ de posibles invitados y un conjunto $E$ de conflictos, formados por pares no ordenados de $V$, queremos encontrar un subconjunto $S \subseteq V$ de cardinalidad máxima entre aquellos que cumplen que $\{v,w\} \not\in E$ para todo par $v,w \in S$. Por ejemplo, si $S = \{1,2,3,4,5\}$ y $E = \{ \{1,2\}, \{2, 3\}, \{3, 4\}, \{4,5\} \}$, entonces una solución es $S = \{1,3,5\}$, ya que no se puede invitar a ningún conjunto de $4$ personas.  Vamos a suponer que los posibles invitados se representan con el conjunto $V = \{1, \ldots, n\}$ para algún $n \geq 0$ (el caso $n=0$ es válido y representa el conjunto $V = \emptyset$).
\label{ejercicioFiesta}

 \begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
  \item Decimos que $S \subseteq \mathbb{N}$ y $W \subseteq \mathbb{N}$ son \emph{compatibles} cuando $S \subseteq V$ es un conjunto posible de invitados y ningún elemento de $W \subseteq V \setminus S$ tiene un conflicto con algún elemento de $S$.  En el ejemplo anterior, $S = \{1\}$ y $W = \{4, 5\}$ son compatibles pero $S = \{1,4\}$ y $W = \{2\}$ no lo son.  Sea $\mathcal{V}$ el conjunto de subconjuntos de $V$.  Escribir una función recursiva $\Fiesta \colon \mathcal{V} \times \mathcal{V} \to \mathcal{V}$ tal que, dados $S$ y $W$ compatibles, $\Fiesta(S, W)$ retorne un conjunto de invitados de máxima cardinalidad que contenga a $S$.  (Notar que la llamada recursiva debe garantizar la compatibilidad).  \textbf{Ayuda:} considerar dos posibilidades: no invitar a $w \in W$, o invitar a $w \in W$ y no invitar a nadie que tenga un conflicto con $w$.
  \label{fiestaFormRec}

  \item En base a \ref{fiestaFormRec}, implementar un algoritmo recursivo de \emph{backtracking} para resolver el problema de la fiesta basado en las siguientes ideas:
  \begin{itemize}
   \item cada solución parcial es un conjunto $S \subseteq V$ que no contiene invitados con conflictos.
   \item a cada nodo del árbol de \textit{backtracking} se le asocia un conjunto $W \subseteq V$ compatible con $S$ de posibles invitados.
   \item para la extensión, se consideran dos posibilidades: o bien no se invita a $w \in W$ o bien se invita a $w$ y se eliminan de $W$ todos los otros elementos que estén en conflicto con $w$.
  \end{itemize}
  \label{fiestaAlgo1}
  \item Escribir los tres primeros niveles del árbol de \textit{backtracking} resultante de la implementación anterior.
  \item Describir una regla de optimalidad para poder podar el árbol e incluirla en la implementación de \ref{fiestaAlgo1}.
  \item\label{ej:ind set:dp} ¿Se le ocurre una forma de escribir una función recursiva $\FiestaPD(V, S, i)$ que, en analogía con el inciso~\ref{ej:subset sum dp:recursion} del Ejercicio~\ref{ej:subset sum dp}, determine el conjunto de invitados óptimo que incluya a $S \subseteq \{1, \ldots, i-1\}$ y que se obtenga agregando sólo invitados de $\{i, \ldots, n\}$? ¿Cuál es el problema?  ¿Se le ocurre alguna manera de escapar a este problema?
  \item Considerando la función $\Fiesta$ (definida en \ref{fiestaFormRec}) y el inciso anterior, observar que la cantidad posible de instancias es $\Omega(2^n)$.  Concluir que la función $\Fiesta$ no tiene la propiedad de superposición de subproblemas para el caso general del problema de la fiesta.
 \end{enumerate}
 
./exercises/ViajedeTomas.txt
\item Tomás quiere viajar de Buenos Aires a Mar del Plata en su flamante Renault 12. Como está preocupado por la autonomía de su vehículo, se tomó el tiempo de anotar las distintas estaciones de servicio que se encuentran en el camino. Modeló el mismo como un segmento de $0$ a $M$, donde Buenos aires está en el kilómetro 0, Mar del Plata en el $M$, y las distintas estaciones de servicio están ubicadas en los kilómetros $0 = x_1 \leq x_2 \leq \ldots x_n \leq M$.

Razonablemente, Tomás quiere minimizar la cantidad de paradas para cargar nafta. Él sabe que su auto es capaz de hacer hasta $C$ kilómetros con el tanque lleno, y que al comenzar el viaje este está vacío.

\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
    
    \item Proponer un algoritmo \textit{greedy} que indique cuál es la cantidad mínima de paradas para cargar nafta que debe hacer Tomás, y que aparte devuelva el conjunto de estaciones en las que hay que detenerse. Probar su correctitud.\label{tomasIdea}

    \item Dar una implementación de complejidad temporal $O(n)$ del algoritmo del inciso \ref{tomasIdea}.
\end{enumerate}
./exercises/OptimizacióndeTrayectoriasconRestricciones.txt

\begin{enumerate}[$1)$]
 \item La cantidad de combustible consumida por un avión en un viaje dado depende en gran parte de la resistencia que ofrece el aire a la aeronave durante el trayecto. Por ello, es de interés calcular la ruta que incurra en la menor resistencia posible. En este ejemplo simplificado, un avión debe realizar un viaje de $N$ minutos entre dos ciudades. Si bien el curso está prefijado, el avión puede variar la altitud a la que viaja dentro de $H$ bandas posibles numeradas de $0$ a $H-1$. Se tiene un estimativo de la resistencia que provocará viajar durante el minuto $n$ en la banda de altitud $h$, que por simplicidad podemos suponer que tenemos en forma de una tabla $R$ donde $R[i,j]$ es un valor natural que representa la resistencia al aire esperada en el minuto $i$ de vuelo si se está en la banda de altitud $j$. Para moverse entre dos bandas de altitud, el avión debe pasar por todas las bandas intermedias. Pasar de una banda de altitud a una adyacente (da igual si es subiendo o bajando) requiere realizar una maniobra que dura 3 minutos, cuya resistencia se estima como la del minuto de salida en la banda de salida más el máximo entre las resistencias en ambas bandas durante los dos minutos siguientes, es decir, si se realiza la maniobra entre la banda $X$ y la banda $X+1$  desde el minuto 1 al minuto 4, la resistencia al aire será la del minuto 1 en la banda $X$ más el máximo entre la resistencia en la banda $X$ y en la banda $X+1$ en el minuto 2 más el máximo de la resistencia entre la banda $X$ y la banda $X+1$ en el minuto 3. Por ejemplo, para un viaje de 10 minutos con la siguiente tabla de resistencias $R$,

 \begin{center}
     \centering
     \newcommand{\myline}{\cline{3-12}}
     \newcommand{\noline}[1]{\multicolumn{1}{c}{#1}}
     \begin{tabular}{c c|c|c|c|c|c|c|c|c|c|c|}
         \noline{} & \noline{} & \multicolumn{10}{c}{minuto} \\
         \noline{} & \noline{} & \noline{0} & \noline{1} & \noline{2} & \noline{3} & \noline{4} & \noline{5} & \noline{6} & \noline{7} & \noline{8} & \noline{9}\\
         \myline
               & $2$ & $7$ & $7$ & $7$ & $6$ & $6$ & $7$ & $6$ & $6$ & $7$ & $6$\\
         \myline
         banda & $1$ & $6$ & $5$ & $4$ & $3$ & $4$ & $3$ & $4$ & $4$ & $4$ & $4$ \\
         \myline
               & $0$ & $3$ & $5$ & $5$ & $5$ & $5$ & $5$ & $5$ & $3$ & $2$ & $2$ \\
         \myline
     \end{tabular}
 \end{center}

 podemos considerar la resistencia del camino que se encuentra saliendo de la banda $0$ y subiendo en el minuto $0$, luego pasando los minutos $3$ y $4$ en la banda $1$, volviendo a bajar a la banda $0$ en el minuto $5$ y permaneciendo allí. En ese caso, la resistencia total es
 \begin{equation*}
 13 + 3 + 4 + 12 + 2 + 2 = 36
 \end{equation*}

 Donde el término de valor $13$ se calcula como $R[0,0]+\max\{R[1,0],R[1,1]\}+\max\{R[2,0],R[2,1]\}$ y el $12$ como $R[5,1]+\max\{R[6,0],R[6,1]\}+\max\{R[7,0],R[7,1]\}$.

 Se desea conocer cuál es la mínima resistencia total posible para el vuelo programado, conociendo que al inicio del viaje y al final se debe estar en la banda de altura $0$. En el ejemplo mostrado, el camino presentado es óptimo.

 \begin{enumerate}[$a)$]
  \item Definir en forma recursiva la función $f_R \colon \nat \times \nat \to \nat$ tal que $f_R(n,h)$ representa la mínima resistencia de aire total estimada que puede afrontar un avión desde el minuto $0$ hasta el minuto $n$ del vuelo proyectado, si al minuto $0$ estaba en la banda de altitud $0$ y en el momento $n$ se encuentra en la banda $h$. Indicar qué llamado(s) hay que hacer a esta función para resolver el problema. \textbf{Importante:} acompañen a la definición recursiva con una explicación en castellano.

  \item Argumentar en qué casos $f_R$ posee la propiedad de superposición de subproblemas.

  \item Definir un algoritmo \textit{top-down} para calcular $f_R(n,h)$ indicando claramente las estructuras de datos utilizadas y la complejidad resultante. Escribir el (pseudo-)código del algoritmo. ¿Es la complejidad obtenida polinomial?

  \item Sin modificar el algoritmo anterior, pero suponiendo que ya fue ejecutado, explicar cómo determinar las bandas de alturas en las que debe viajar el avión para alcanzar la resistencia mínima calculada.
 \end{enumerate}

 \textbf{Criterio de aprobación:} La función descripta en el inciso a) debe ser correcta y estar adecuadamente justificada, y la complejidad temporal del algoritmo resultante para computar $f_R(n,h)$ en el inciso c) debe ser $O(N H)$ (y también estar justificada).

./exercises/Placeholder.txt
Placeholder
./exercises/ParejasdeBaile.txt
\item Tenemos dos conjuntos de personas y para cada persona sabemos su habilidad de baile. Queremos armar la máxima cantidad de parejas de baile, sabiendo que para cada pareja debemos elegir exactamente una persona de cada conjunto de modo que la diferencia de habilidad sea menor o igual a 1 (en módulo). Además, cada persona puede pertenecer a lo sumo a una pareja de baile.  Por ejemplo, si tenemos un multiconjunto con habilidades $\{ 1, 2, 4, 6 \}$ y otro con $\{ 1, 5, 5, 7, 9 \}$, la máxima cantidad de parejas es 3. Si los multiconjuntos de habilidades son $\{ 1, 1, 1, 1, 1 \}$ y $\{ 1, 2, 3 \}$, la máxima cantidad es 2.
\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
\item Considerando que ambos multiconjuntos de habilidades estan ordenados en forma creciente, observar que la solución se puede obtener recorriendo los multiconjuntos en orden para realizar los emparejamientos.
\label{baileIdea}
\item Diseñar un algoritmo goloso basado en \ref{baileIdea} que recorra una única vez cada multiconjunto. Explicitar la complejidad temporal y espacial auxiliar.
\label{baileAlgo}
\item Demostrar que el algoritmo dado en \ref{baileAlgo} es correcto.
\end{enumerate}
./exercises/DivisiondeCursos.txt
\item En medio de una pandemia, la Escuela de Aulas Grandes y Ventiladas quiere implementar un protocolo especial de distanciamiento social que tenga en cuenta que la escuela no tienen restricciones de espacio.  El objetivo es separar a cada curso en dos subcursos a fin de reducir la cantidad de pares de estudiantes que sean muy cercanos, dado que se estima que estos estudiantes tienen dificultades para respetar tan buscado distanciamiento.  Para este fin, en el protocolo se estableció que cada curso que tenga $c$ parejas de estudiantes cercanos tiene que dividirse en dos subcursos, cada uno de los cuales puede tener a lo sumo $c/2$ parejas de estudiantes cercanos.  Notar que no importa si un subcurso queda con más estudiantes que otro.

Formalmente, para cada curso contamos con un conjunto de estudiantes $E$ y su conjunto $C$ de pares de estudiantes cercanos.  Luego, una partición $(A,B)$ de $E$ es una \emph{solución factible para $(E, C)$} cuando $|(A\times A) \cap C| \leq |C|/2$ y $|(B \times B) \cap C| \leq |C/2|$.  Por ejemplo, si $E = \{1, 2, 3, 4\}$ y $C = \{1\text{-}2, 2\text{-}3, 3\text{-}4\}$, entonces $(\{1,3,4\}, \{2\})$ y $(\{2,4\}, \{1,3\})$ son soluciones factibles.

\begin{enumerate}[label=$\alph*)$, ref=$\alph*)$]
 \item Especificar el problema descrito definiendo cuál es la instancia (i.e. cuáles son los datos de entrada y qué condiciones satisfacen) y cuál es el resultado esperado (i.e., cuáles son los datos de salida y qué condiciones satisfacen).\label{ej:aulas-grandes:entrada}
 \item Demostrar que para toda instancia existe un resultado esperado que satisface las condiciones definidas por el protocolo.  \textbf{Ayuda:} hacer inducción en la cantidad de estudiantes.  Para el paso inductivo, considerar que si les estudiantes se asignan iterativamente a los subcursos, entonces conviene enviar a cada estudiante al subcurso que tenga la menor cantidad de estudiantes cercanos a elle.
 \item A partir de la demostración del inciso anterior, diseñar un algoritmo que encuentre una solución factible en tiempo lineal en función del tamaño de la entrada definido en el inciso~\ref{ej:aulas-grandes:entrada}.
\end{enumerate}

./exercises/RodCutting.txt
\item Debemos cortar una vara de madera en varios lugares predeterminados. Sabemos que el costo de realizar un corte en una madera de longitud $\ell$ es $\ell$ (y luego de realizar ese corte quedarán 2 varas de longitudes que sumarán $\ell$).  Por ejemplo, si tenemos una vara de longitud 10 metros que debe ser cortada a los 2, 4 y 7 metros desde un extremo, entonces los cortes se pueden realizar, entre otras maneras, de las siguientes formas:
\begin{itemize}
\item Primero cortar en la posición 2, después en la 4 y después en la 7. Esta resulta en un costo de 10 + 8 + 6 = 24 porque el primer corte se hizo en una vara de longitud 10 metros, el segundo en una de 8 metros y el último en una de 6 metros.
\item Cortar primero donde dice 4, después donde dice 2, y finalmente donde dice 7, con un costo de 10 + 4 + 6 = 20, que es menor.
\end{itemize}
\par{Queremos encontrar el mínimo costo posible de cortar una vara de longitud $\ell$.}
\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
\item Convencerse de que el mínimo costo de cortar una vara que abarca desde $i$ hasta $j$ con el conjunto $C$ de lugares de corte es $j-i$ mas el mínimo, para todo lugar de corte $c$ entre $i$ y $j$, de la suma entre el mínimo costo desde $i$ hasta $c$ y el mínimo costo desde $c$ hasta $j$.
\label{maderaFormRec1}
\item Escribir matemáticamente una formulación recursiva basada en \ref{maderaFormRec1}. Explicar su semántica e indicar cuáles serían los parámetros para resolver el problema.
\item Diseñar un algoritmo de PD y dar su complejidad temporal y espacial auxiliar. Comparar cómo resultaría un enfoque \textit{top-down} con uno \textit{bottom-up}.
\label{maderaComplejidad1}
\item Supongamos que se ordenan los elementos de $C$ en un vector $cortes$ y se agrega un $0$ al principio y un $\ell$ al final. Luego, se considera que el mínimo costo para cortar desde el $i$-ésimo punto de corte en $cortes$ hasta el $j$-ésimo punto de corte será el resultado buscado si $i = 1$ y $j = |C| + 2$.
\label{maderaFormRec2}
\begin{enumerate}[label=$\roman*)$,ref=$\roman*)$]
\item Escribir una formulación recursiva con dos parámetros que esté basada en \ref{maderaFormRec2} y explicar su semántica.
\item Diseñar un algoritmo de PD, dar su complejidad temporal y espacial auxiliar y compararlas con aquellas de \ref{maderaComplejidad1}. Comparar cómo resultaría un enfoque \textit{top-down} con uno \textit{bottom-up}.
\end{enumerate}
./exercises/TerrenodeTrampas.txt
\item Hay un terreno, que podemos pensarlo como una grilla de $m$ filas y $n$ columnas, con trampas y pociones. Queremos llegar de la esquina superior izquierda hasta la inferior derecha, y desde cada casilla sólo podemos movernos a la casilla de la derecha o a la de abajo. Cada casilla $i$,$j$ tiene un número entero $A_{i,j}$ que nos modificará el nivel de vida sumándonos el número $A_{i,j}$ (si es negativo, nos va a restar $|A_{i,j}|$ de vida). Queremos saber el mínimo nivel de vida con el que debemos comenzar tal que haya un camino posible de modo que en todo momento nuestro nivel de vida sea al menos 1. Por ejemplo, si tenemos la grilla
\[ A = \begin{bmatrix}
-2 & -3 & 3 \\
-5 & -10 & 1 \\
10 & 30 & -5
\end{bmatrix} \]
\par{el mínimo nivel de vida con el que podemos comenzar es 7 porque podemos realizar el camino que va todo a la derecha y todo abajo.}
\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
\item Pensar la idea de un algoritmo de \textit{backtracking} (no hace falta escribirlo).
\item Convencerse de que, excepto que estemos en los límites del terreno, la mínima vida necesaria al llegar a la posición $i, j$ es el resultado de restar al mínimo entre la mínima vida necesaria en $i+1, j$ y aquella en $i, j+1$, el valor $A_{i,j}$, salvo que eso fuera menor o igual que 0, en cuyo caso sería 1.
\label{terrenoFormRec}
\item Escribir una formulación recursiva basada en \ref{terrenoFormRec}. Explicar su semántica e indicar cuáles serían los parámetros para resolver el problema.
\item Diseñar un algoritmo de PD y dar su complejidad temporal y espacial auxiliar. Comparar cómo resultaría un enfoque \textit{top-down} con uno \textit{bottom-up}.
\item Dar un algoritmo \textit{bottom-up} cuya complejidad temporal sea $\mathcal{O}(m \cdot n)$ y la espacial auxiliar sea $\mathcal{O}(\min(m, n))$.
\end{enumerate}
./exercises/LanzamientodeDados.txt
\item Se arrojan simultáneamente $n$ dados, cada uno con $k$ caras numeradas de $1$ a $k$. Queremos calcular todas las maneras posibles de conseguir la suma total $s \in \mathbb{N}$ con una sola tirada. Tomamos dos variantes de este problema.

\begin{enumerate}[label=$(\Alph*)$,ref=$(\Alph*)$]
\item Consideramos que los dados son \textbf{distinguibles}, es decir que si $n = 3$ y $k = 4$, entonces existen $10$ posibilidades que suman $s = 6$:
\begin{enumerate}
\item $4$ posibilidades en las que el primer dado vale $1$
\item $3$ posibilidades en las que el primer dado vale $2$
\item $2$ posibilidades en las que el primer dado vale $3$
\item Una posibilidad en la que el primer dado vale $4$
\end{enumerate}\label{ejdados:distinguibles}
\item Consideramos que los dados son \textbf{indistinguibles}, es decir que si $n = 3$ y $k = 4$, entonces existen $3$ posibilidades que suman $s = 6$:
\begin{enumerate}
\item Un dado vale $4$, los otros dos valen $1$
\item Un dado vale $3$, otro $2$ y otro $1$
\item Todos los dados valen $2$
\end{enumerate}\label{ejdados:indistinguibles}
\end{enumerate}

\begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
  \item Definir en forma recursiva la función $f \colon \mathbb{N}^2 \to \mathbb{N}$ tal que $f(n, s)$ devuelve la respuesta para el escenario~\ref{ejdados:distinguibles} (fijado $k$).
  \item Definir en forma recursiva la función $g \colon \mathbb{N}^3 \to \mathbb{N}$ tal que $f(n, s, k)$ devuelve la respuesta para el escenario~\ref{ejdados:indistinguibles}.
  \item Demostrar que $f$ y $g$ poseen la propiedad de superposición de subproblemas.
  \item Definir algoritmos \textit{top-down} para calcular $f(n, s)$ y $g(n, s, k)$ indicando claramente las estructuras de datos utilizadas y la complejidad resultante.
  \item Escribir el (pseudo-)código de los algoritmos top-down resultantes.
\end{enumerate}
 \textbf{Nota:} Una solución correcta de este ejercicio debería indicar cómo se computa tanto $f(n,s)$ como $g(n,s,k)$ en tiempo $O(nk\min\{s, nk\})$.

\end{enumerate}


./exercises/SumadeSubconjuntosPD.txt
\begin{enumerate}[resume*]

\item\label{ej:subset sum dp} En este ejercicio vamos a resolver el problema de suma de subconjuntos usando la técnica de programación dinámica.

 \begin{enumerate}[label=$\alph*)$,ref=$\alph*)$]
  \item\label{ej:subset sum dp:recursion} Sea $n = |C|$ la cantidad de elementos de $C$.  Considerar la siguiente función recursiva $\SubsetSumPD_C \colon \{0,\ldots, n\} \times \{0, \ldots, k\} \to \{V,F\}$ (donde $V$ indica verdadero y $F$ falso) tal que:
  \begin{displaymath}
   \SubsetSumPD_C(i, j) = \begin{cases}
    j = 0 & \text{si $i = 0$} \\
    \SubsetSumPD_C(i-1,j) & \text{si $i \neq 0 \land C[i] > j$} \\
    \SubsetSumPD_C(i-1, j) \lor \SubsetSumPD_C(i-1, j- C[i]) & \text{si no}
   \end{cases}
  \end{displaymath}
  Convencerse de que esta es una definición equivalente de la función $\SubsetSum$ del inciso~\ref{sumaDeSubconjuntosFormRecBT} del Ejercicio~\ref{ejercicioSumaDeSubconjuntos}, observando que $\SubsetSum(C, k) = \SubsetSumPD_C(n, k)$.  En otras palabras, convencerse de que el algoritmo del inciso \ref{sumaDeSubconjuntosAlgoBT} es una implementación por \textit{backtracking} de la función $\SubsetSumPD_C$.  Concluir, pues, que $\mathcal{O}(2^n)$ llamadas recursivas de $\SubsetSumPD_C$ son suficientes para resolver el problema.
  \item Observar que, como $C$ no cambia entre llamadas recursivas, existen $\mathcal{O}(nk)$ posibles entradas para $\SubsetSumPD_C$. Concluir que, si $k \ll 2^n/n$, entonces necesariamente algunas instancias de $\SubsetSumPD_C$ son calculadas muchas veces por el algoritmo del inciso \ref{sumaDeSubconjuntosAlgoBT}. Mostrar un ejemplo donde se calcule varias veces la misma instancia.
  \item Considerar la estructura de memoización (i.e., el diccionario) $M$ implementada como una matriz de $(n+1) \times (k+1)$ tal que $M[i,j]$ o bien tiene un valor indefinido $\bot$ o bien tiene el valor $\SubsetSumPD_C(i, j)$, para todo $0 \leq i \leq n$ y $0 \leq j \leq k$.  Convencerse de que el siguiente algoritmo \emph{top-down} mantiene un estado válido para $M$ y computa $M[i, j] = \SubsetSumPD_C(i, j)$ cuando se invoca $\SubsetSumPD_C(i, j)$.

  \begin{enumerate}
   \item Inicializar $M[i,j] = \bot$ para todo $0 \leq i \leq n$ y $0 \leq j \leq k$.
   \item $\SubsetSumAlg(C, i, j)$: // implementa $\SubsetSum(\{c_1, \ldots, c_i\}, j) = \SubsetSumPD_C(i,  j)$ usando memoización
   \item ~~~~Si $j < 0$, retornar \textbf{falso}
   \item ~~~~Si $i = 0$, retornar $(j = 0)$
   \item ~~~~Si $M[i, j] = \bot$:
   \item ~~~~~~~~Poner $M[i, j] = \SubsetSumAlg(C, i-1, j) \lor \SubsetSumAlg(C, i-1, j - C[i])$
   \item ~~~~Retornar $M[i, j]$
  \end{enumerate}

  \item Concluir que $\SubsetSumAlg(C, n, k)$ resuelve el problema.  Calcular la complejidad y compararla con el algoritmo $\SubsetSumAlg$ del inciso \ref{sumaDeSubconjuntosAlgoBT} del Ejercicio \ref{ejercicioSumaDeSubconjuntos}. ¿Cuál algoritmo es mejor cuando $k \ll 2^n$?  ¿Y cuándo $k \gg 2^n$?

  \item Supongamos que queremos computar todos los valores de $M$.  Una vez computados, por definición, obtenemos que
  \begin{displaymath}
   M[i,j] \stackrel{\rm def}{=} \SubsetSumPD_C(i, j) \stackrel{\SubsetSumPD}{=} \SubsetSumPD_C(i-1, j) \lor \SubsetSumPD_C(i-1, j-C[i]) \stackrel{\rm def}{=} M[i-1, j] \lor M[i-1, j-C[i]]
  \end{displaymath}
  cuando $i > 0$, asumiendo que $M[i-1, j-C[i]]$ es falso cuando $j-C[i] < 0$.  Por otra parte, $M[0, 0]$ es verdadero, mientras que $M[0, j]$ es falso para $j > 0$.  A partir de esta observación, concluir que el siguiente algoritmo \emph{bottom-up} computa $M$ correctamente y, por lo tanto, $M[i, j]$ contiene la respuesta al problema de la suma para todo $\{c_1, \ldots, c_i\}$ y $j$.

  \begin{enumerate}
   \item $\SubsetSumAlg(C, k)$: // computa $M[i,j]$ para todo $0 \leq i \leq n$ y $0 \leq j \leq k$.
   \item ~~~~Inicializar $M[0,j] := (j = 0)$ para todo $0 \leq j \leq k$.
   \item ~~~~Para $i = 1, \ldots, n$ y para $j = 0, \ldots, k$:
   \item ~~~~~~~~Poner $M[i, j] := M[i-1, j] \lor (j-C[i] \geq 0 \land M[i-1, j-C[i]])$
  \end{enumerate}
  \item (Opcional) Modificar el algoritmo \textit{bottom-up} anterior para mejorar su complejidad espacial a $O(k)$.
  \item (Opcional) Demostrar que la función recursiva del inciso~\ref{ej:subset sum dp:recursion} es correcta.  \textbf{Ayuda:} demostrar por inducción en $i$ que existe algún subconjunto de $\{c_1, \ldots, c_i\}$ que suma $j$ si y solo si $\SubsetSumPD_C(i, j) = V$.
 \end{enumerate}

./environment_check.py
import pkg_resources



installed_packages = [(d.project_name, d.version) for d in pkg_resources.working_set]

installed_packages./.pytest_cache/README.md
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.
./requirements.txt
Flask==2.3.2
oauthlib==3.2.2
gunicorn==21.2.0
openai==0.27.8
authlib==1.3.0
flask_session==0.6.0
requests
python-dotenv==1.0.0
pandas
pytest
Markdown==3.4.4
./privacy_policy.txt
# Política de Privacidad de Nuestra Aplicación Web

## Introducción

Nuestra aplicación web respeta la privacidad de sus usuarios y está comprometida a proteger la información personal de los mismos. Esta política de privacidad describe los tipos de información que recopilamos, cómo se utiliza y las medidas que tomamos para asegurar que tu información esté protegida.

## Recolección y Uso de Información

### Información Personal

Al utilizar nuestra aplicación web, se te puede solicitar que proporciones información personal, como tu nombre, dirección de correo electrónico y otros detalles de contacto. Esta información se utiliza para personalizar tu experiencia, proporcionar soporte al cliente y comunicar actualizaciones o información importante relacionada con la aplicación.

### Datos de Uso

Recopilamos información sobre cómo se accede y utiliza la aplicación. Esto puede incluir información como la dirección IP de tu dispositivo, el tipo de navegador, las páginas de nuestra aplicación que visitas, la hora y fecha de tu visita, el tiempo que pasas en esas páginas y otros datos de diagnóstico.

## Seguridad de la Información

La seguridad de tu información es importante para nosotros. Implementamos una variedad de medidas de seguridad para mantener la seguridad de tu información personal. Sin embargo, recuerda que ningún método de transmisión por Internet o método de almacenamiento electrónico es 100% seguro.

## Cambios a Esta Política de Privacidad

Nos reservamos el derecho de modificar nuestra política de privacidad en cualquier momento. Te notificaremos de cualquier cambio publicando la nueva política de privacidad en esta página. Te recomendamos revisar esta política de privacidad periódicamente para estar informado de cualquier cambio.

## Contacto

Si tienes preguntas sobre esta política de privacidad, por favor, contáctanos a través de nuestra página de contacto en la aplicación.

