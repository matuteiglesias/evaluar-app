ID,Nombre,Descripción
101,SumaSubconjuntosBT,"Este ejercicio desafía a encontrar subconjuntos dentro de un multiconjunto de números naturales cuya sumatoria sea un valor específico, utilizando la técnica de *backtracking*. Se exploran las soluciones candidatas, válidas y parciales, junto con la implementación de una función recursiva para determinar la existencia de dichos subconjuntos, incluyendo optimizaciones mediante reglas de factibilidad y la modificación de la implementación para revelar el subconjunto solución."
102,MagiCuadrados,"El desafío consiste en calcular cuántos cuadrados mágicos de orden $n$ se pueden formar, utilizando métodos de fuerza bruta y optimización mediante backtracking y podas inteligentes, poniendo a prueba la habilidad para manejar permutaciones y optimizar la búsqueda de soluciones en un espacio combinatorio extenso."
103,MaxiSubconjunto,"El desafío consiste en encontrar un subconjunto de tamaño $k$ dentro de una matriz simétrica $n \times n$ que maximice la suma de sus elementos interconectados. Se aborda mediante un algoritmo de backtracking, evaluando su eficiencia y aplicando podas por optimalidad."
104,RutaMinima,"El objetivo es encontrar la permutación de índices que minimice la suma de distancias entre puntos consecutivos en una matriz, diseñando un algoritmo de backtracking con poda por optimalidad, y analizando su complejidad."
105,SumaDinámica,"Este ejercicio aborda el problema de la suma de subconjuntos, aplicando técnicas de programación dinámica tanto en enfoques top-down con memoización como bottom-up, para optimizar el cálculo y reducir la complejidad temporal y espacial del problema."
106,OptiPago,"En este desafío, el objetivo es determinar la forma óptima de pagar un costo fijo usando un subconjunto de billetes disponibles, minimizando tanto el exceso de pago como la cantidad de billetes utilizados. Se exploran estrategias de backtracking, programación dinámica y memoización para encontrar la solución más eficiente."
107,AstroTrade,"El desafío **AstroTrade** consiste en maximizar la ganancia neta de la compra-venta de asteroides a lo largo de una secuencia de $n$ días, con la restricción de realizar a lo sumo una operación (compra o venta) por día y empezando sin asteroides, empleando para ello formulación recursiva y programación dinámica."
108,CortesEconómicos,"El objetivo es determinar la estrategia de cortes mínimos en una vara de madera, dadas posiciones específicas, para minimizar el costo total de cortarla. Se explora la solución mediante programación dinámica, comparando enfoques top-down y bottom-up."
109,Travesía Vital,"En este desafío, el objetivo es calcular el mínimo nivel de vida necesario para atravesar una grilla llena de trampas y pociones, moviéndose solo hacia la derecha o abajo, de manera que siempre se mantenga vivo. Se exploran enfoques de backtracking, programación dinámica (PD) tanto top-down como bottom-up, y se busca una solución óptima en términos de complejidad temporal y espacial."
110,PilaCauta,"El ejercicio **PilaCauta** desafía a encontrar la máxima cantidad de cajas numeradas que se pueden apilar de manera creciente sin exceder el límite de soporte de cada caja. Se exploran soluciones mediante backtracking y programación dinámica, enfocándose en optimizar la selección basada en el peso y soporte de cada caja."
111,OperacionesSeq,"El objetivo es intercalar operaciones de suma, multiplicación y potenciación entre los elementos de un vector de números naturales para obtener un resultado específico, siguiendo una evaluación de izquierda a derecha. Se busca diseñar un algoritmo de Programación Dinámica (PD) que encuentre la secuencia de operaciones adecuada, si existe, optimizando tanto en enfoques top-down como bottom-up."
112,DadosSuma,"Este ejercicio desafía a calcular todas las combinaciones posibles para obtener una suma específica arrojando simultáneamente $n$ dados con $k$ caras, considerando escenarios donde los dados son distinguibles e indistinguibles. Se busca definir funciones recursivas y algoritmos eficientes con una complejidad objetivo, explorando la propiedad de superposición de subproblemas."
113,DadosDinámicos,"Este ejercicio desafía a calcular el número de formas de alcanzar una suma específica al lanzar $n$ dados, cada uno con $k$ caras, bajo dos escenarios: dados distinguibles e indistinguibles. Se requiere definir y demostrar funciones recursivas y algoritmos top-down, optimizando el cálculo para ejecutarse en tiempo $O(nk\min\{s, nk\})$."
114,SumaSelectiva,"El desafío consiste en encontrar el subconjunto de tamaño $k$ de un conjunto dado $X$, cuya suma de elementos sea máxima. Se explora el diseño de un algoritmo *greedy*, seguido de implementaciones eficientes con complejidades $O(n\log n)$ y $O(n \log k)$, demostrando variadas aproximaciones para optimizar la solución."
115,SumaGolosa,"Este ejercicio desafía a encontrar la estrategia más eficiente para sumar elementos de un multiconjunto de números naturales, minimizando el coste total de las operaciones. Se explora una solución golosa, demostrando su validez y se implementa con una complejidad de $\mathcal{O}(n\log n)$ usando secuencias ordenadas."
116,RutaEficiente,"Tomás necesita planificar el viaje más eficiente de Buenos Aires a Mar del Plata, minimizando las paradas para recargar combustible en su Renault 12, dada la capacidad limitada de su tanque. El desafío consiste en diseñar un algoritmo voraz que determine el número mínimo de paradas necesarias y su implementación en tiempo lineal."
117,División Pandémica,"En el contexto de una pandemia, el desafío consiste en dividir cada curso de una escuela en dos subcursos de manera que se minimice la cantidad de pares de estudiantes cercanos en cada subgrupo, sin restricciones de espacio. La solución debe satisfacer la condición de que cada subcurso tenga a lo sumo la mitad de las parejas cercanas del curso original, sin importar la distribución numérica de estudiantes entre subcursos."
118,MaxMex,"El desafío consiste en encontrar la permutación de un vector dado que maximiza la suma de los valores mínimos excluidos (mex) de sus subconjuntos crecientes. Se busca diseñar un algoritmo voraz (greedy) eficiente, con una implementación de complejidad temporal O(n), explorando las propiedades de la función mex y las relaciones entre subconjuntos."
119,CacheOpt,"El desafío **CacheOpt** se enfoca en optimizar la gestión de una caché de tamaño limitado para minimizar los *cache misses* al procesar una secuencia de solicitudes de acceso a memoria, aplicando la estrategia *furthest-in-future* y desarrollando un algoritmo eficiente para su implementación."
120,Invitación Estratégica,"El desafío consiste en determinar el conjunto más grande de invitados a una fiesta evitando conflictos entre ellos, aplicando técnicas de recursividad y *backtracking* para encontrar la solución óptima. Este problema pone a prueba la habilidad para manejar subconjuntos y optimizar decisiones bajo restricciones específicas."
121,FiestaSelectiva,"El desafío consiste en seleccionar el máximo número de actividades (invitados) que puedan realizarse (asistir a una fiesta) sin solaparse en tiempo, aplicando estrategias de backtracking, programación dinámica y algoritmos golosos para encontrar la solución óptima."
201,IzquierdaDominante,"El ejercicio desafía a crear un algoritmo usando la estrategia de dividir y conquistar para verificar si un arreglo de tamaño potencia de 2 cumple con ser ""más a la izquierda"", es decir, que la suma de los elementos de la mitad izquierda de cada subdivisión siempre supera a la de la derecha, con una eficiencia mayor a O(n^2)."
202,ÍndiceEspejo,"Diseña un algoritmo dividir y conquistar para encontrar si existe un índice en un arreglo ordenado de enteros distintos donde el valor y el índice coinciden, optimizando la búsqueda para superar la eficiencia lineal."
203,PotenciaLogarítmica,"El desafío consiste en diseñar un algoritmo eficiente que calcule $a^b$ aprovechando la descomposición de potencias para operar en tiempo logarítmico respecto a $b$, enfocándose en la optimización mediante la reutilización de cálculos previos."
204,ComplexityQuest,"Este ejercicio desafía a calcular la complejidad temporal de diferentes algoritmos siguiendo sus ecuaciones de recurrencia, aplicando tanto estimaciones directas como el teorema maestro. Ideal para afianzar conceptos de complejidad algorítmica y análisis de recurrencias."
205,PotenciaSum,"Diseña un algoritmo utilizando dividir y conquistar junto al método *potencia* para calcular la suma de potencias consecutivas \(A^1 + A^2 + \ldots + A^n\) de una matriz \(4 \times 4\), donde \(n\) es una potencia de \(2\), optimizando el número de veces que se aplica el método *potencia* para que sea menor que \(O(n)\)."
206,DistanciaMáxima,"Diseña un algoritmo de dividir y conquistar para encontrar la máxima distancia entre dos nodos en un árbol binario, optimizando el proceso para evitar recorridos innecesarios del árbol."
207,DesordenSort,"Diseña un algoritmo optimizado, basado en una variante de un método de ordenamiento, para contar cuántas parejas de elementos en un arreglo están en desorden, superando la eficiencia de una solución $O(n^2)$."
208,CazadorDeFalsos,"El objetivo es diseñar algoritmos eficientes para localizar y contar elementos falsos en una matriz booleana, utilizando una operación de conjunción en submatrices que opera en tiempo constante, con restricciones específicas que desafían la eficiencia en términos de complejidad computacional."
209,MergeSelectivo,"Encuentra el $i$-ésimo elemento en la unión ordenada de dos arreglos sin realizar el merge completo, optimizando el proceso con un algoritmo de complejidad $O(\log^2 n)$ y desafiando a alcanzar $O(\log n)$. Cada número natural se asume único en su respectivo arreglo."
210,"""Diferencia Mínima""","El desafío consiste en implementar un algoritmo eficiente, con complejidad $O(\log n)$, para encontrar el mínimo valor de la diferencia absoluta entre los elementos correspondientes de dos arreglos de naturales de igual tamaño, uno ordenado en forma creciente y el otro en forma decreciente."
211,SubBúsqueda,"El desafío consiste en diseñar un algoritmo que, utilizando una función especial de búsqueda en intervalos, localice eficientemente el índice de un elemento dado en un arreglo de números naturales, asegurando que su complejidad temporal sea sublineal en relación al tamaño del arreglo."
212,L-Tetris,"Diseña un algoritmo de dividir y conquistar para llenar un tablero $n \times n$ con piezas en forma de ""L"", garantizando que cada número se repita exactamente tres veces sin exceder dos repeticiones por fila o columna."
301,Equilibrio Digrafo,"Demuestra mediante inducción que en cualquier digrafo, la suma de grados de entrada y salida de todos sus vértices es igual al número total de aristas. Este desafío pone a prueba tu comprensión sobre la estructura y propiedades fundamentales de los digrafos."
302,Doble Grado,"Demuestra, mediante reducción al absurdo, que en cualquier grafo no trivial existen al menos dos vértices con el mismo grado, observando cuidadosamente la secuencia de grados."
303,Unicidad Digrafo,"Demuestra constructivamente que para cada número entero \(n\), existe un único grafo orientado donde todos los vértices tienen grados de salida distintos, utilizando la lógica de construcción y el principio del absurdo."
304,ArteConexo,"Este desafío te invita a explorar la frontera entre grafos conexos y biconexos a través de demostraciones matemáticas, usando inducción y reducción al absurdo para descubrir condiciones que garantizan ambas propiedades en función del número de aristas."
305,CicloCompartido,"El desafío consiste en demostrar la existencia de un ciclo dentro de un grafo, utilizando dos caminos distintos que conectan el mismo par de vértices. La clave está en identificar y definir los subcaminos de ambos que, al unirse, forman este ciclo."
306,Intersección Máxima,"Demostrar que en un grafo conexo, cualquier par de caminos simples de máxima longitud comparten al menos un vértice, empleando un argumento contrarrecíproco basado en la suposición de la existencia de dos caminos disjuntos de igual longitud máxima."
307,UniónVsJunta,"Este ejercicio desafía a demostrar las relaciones entre grafos unión y grafos junta, especialmente cómo estas estructuras se traducen en propiedades de conectividad y sus complementos. Se enfoca en establecer vínculos directos entre ser un grafo unión y ser disconexo, así como entre ser un grafo junta y la desconexión en el grafo complementario."
308,Unicidad de Grados,"Demuestra, usando inducción, que en una secuencia específica de grafos generados a partir de $K_2$ y operaciones de complemento y unión, cada grafo resultante contiene exactamente un par de vértices con el mismo grado, resaltando la singularidad estructural de estos grafos."
309,Triángulo Inductivo,"Este ejercicio desafía a demostrar, usando inducción, que cualquier grafo con más de $n^2$ aristas y $2n$ vértices inevitablemente contiene al menos un triángulo, y plantea la búsqueda de una cota más eficiente para la existencia de triángulos en grafos grandes."
310,Bipartito o Ciclo,"Demuestra que un grafo menos un vértice es bipartito si y solo si el grafo original es bipartito o forma un ciclo impar, utilizando razonamiento contrarrecíproco y directo."
311,Vecindarios Graficales,"Este ejercicio desafía a analizar y comparar la eficiencia de diferentes estructuras de datos (lista de adyacencias, matriz de adyacencias, tabla de hash) para gestionar vecindarios en un grafo, enfocándose en la complejidad temporal y espacial de operaciones comunes como la adyacencia, inserción y eliminación."
312,Adyacencia Eficiente,"Demuestra cómo construir representaciones por listas de adyacencias de un grafo en tiempo óptimo \(O(n+m)\), analizando las diferencias al usar una tabla de hash o una matriz de adyacencias, destacando la eficiencia y posibles compromisos."
313,Gemelos y Mellizos en Grafos,"Este ejercicio explora la identificación y clasificación de vértices gemelos y mellizos en grafos mediante relaciones de equivalencia y la implementación de un algoritmo eficiente para encontrar particiones basadas en vecindarios cerrados, con una mirada especial a la complejidad temporal y las modificaciones necesarias para adaptar el método a diferentes criterios de vecindario."
314,Cazador de Ciclos,"Diseña e implementa algoritmos eficientes para detectar ciclos en digrafos, explorando condiciones específicas de aciclicidad y aplicando conceptos de teoría de grafos para resolver un problema complejo con restricciones de complejidad temporal \(O(n+m)\)."
315,TriánguloGrafo,"Este ejercicio explora tres algoritmos (cúbico, cuadrático y subcuadrático) para identificar si un grafo contiene un triángulo, comparando su eficiencia y analizando casos óptimos y desfavorables."
316,Umbral de Grafos,"Este ejercicio se centra en explorar y demostrar propiedades únicas de los grafos threshold, incluyendo la relación entre los grados de los vértices y sus vecindades, así como diseñar una estructura de datos eficiente y un algoritmo para determinar si un grafo dado cumple con ser un grafo threshold."
317,Aristas Únicas,"Este ejercicio se enfoca en diseñar algoritmos lineales para identificar aristas únicas en multigrafos y aristas unidireccionales en digrafos, poniendo a prueba la habilidad para manipular y analizar estructuras de datos complejas en grafos."
318,CiclosRho,"Este ejercicio desafía a demostrar la existencia de un ciclo único en digrafos con forma de $\rho$ y a diseñar un algoritmo para encontrar todos los ciclos en tales estructuras, aplicando estos conceptos al problema de selección óptima de actividades periódicas."
319,GeoCuadrados,"Este ejercicio desafía a demostrar relaciones entre caminos geodésicos en un grafo y su cuadrado, aplicando reducción al absurdo para explorar la complejidad de grafos completos y restricciones en la longitud de caminos geodésicos."
401,Bipartición y Ciclos,"Diseña un algoritmo lineal para determinar si un grafo conexo es bipartito, retornando su bipartición o un ciclo impar como evidencia. Extiende esta lógica para grafos no conexos, enfocándote en la estructura de árboles generadores y las propiedades de los ciclos."
402,PuentesDFS,"Este ejercicio desafía a demostrar propiedades críticas de las aristas puente en grafos conexos y desarrollar un algoritmo lineal para identificarlas mediante un recorrido DFS, profundizando en la interacción entre ciclos, árboles de expansión y estructura de grafos."
403,ConexiónDFS,"Este ejercicio desafía a analizar y probar la equivalencia entre la fuerte conectividad de orientaciones en grafos y la ausencia de puentes, utilizando árboles DFS. Además, se solicita desarrollar un algoritmo lineal para identificar una orientación fuertemente conexa en grafos que cumplan con estas condiciones."
404,OrientaCalles,"El desafío consiste en determinar qué calles de una ciudad deben orientarse y en qué sentido para reducir al mínimo posible las que permanecen bidireccionales, empleando un algoritmo eficiente con tiempo O(n+m)."
405,GeoBFS,"Demuestra que cualquier árbol de búsqueda en anchura (BFS) enraizado en un vértice específico preserva las distancias mínimas desde ese vértice a todos los demás, y proporciona un contraejemplo donde un árbol generador que mantiene estas distancias no se deriva de un BFS."
406,GeoÁrbol Mínimo,"Diseña un algoritmo eficiente que, dado un grafo ponderado y un vértice inicial, encuentre el árbol geodésico de menor peso partiendo de dicho vértice, asegurando una complejidad de tiempo O(n+m). Evalúa las aristas críticas para construir la solución óptima."
407,ParMínimo,"Diseña un algoritmo para encontrar el recorrido de longitud par más corto entre dos vértices en un digrafo, aprovechando la transformación del digrafo original en un digrafo bipartito y una versión modificada que considera caminos de dos aristas como una sola conexión. Evalúa la eficiencia de las soluciones propuestas."
408,GrillaMágica,"En este desafío, el objetivo es encontrar la mínima cantidad de movimientos en una grilla $m \times n$ para transformar un valor inicial en un valor objetivo, utilizando operaciones matemáticas específicas en cada paso. El problema se modela y resuelve como un grafo usando BFS con una complejidad de $O(kmn)$."
409,DiviSum,"Diseñar un algoritmo de complejidad $O(ds)$ capaz de hallar el mínimo número divisible por $d$ cuya suma de dígitos sea $s$, o determinar que tal número no existe, empleando la descomposición en dígitos y el análisis de restos y sumatorias parciales."
410,SecuenciasConectadas,"Desarrolla un algoritmo eficiente para encontrar el árbol generador mínimo en un grafo donde los vértices son secuencias de números naturales y las aristas representan la distancia entre estas secuencias, con la particularidad de que la complejidad no debe exceder O(kn^2)."
411,AnchoBandMax,"Este desafío implica diseñar algoritmos eficientes para determinar el ancho de banda máximo en una red modelada como un grafo, considerando tanto la configuración actual como escenarios potenciales tras la mejora de ciertas aristas. El objetivo es optimizar la conectividad de la red bajo diferentes presupuestos de actualización."
412,MaximinBandwidth,"Este desafío se centra en demostrar la equivalencia entre un árbol generador maximin y un árbol generador máximo en grafos, usando el análisis de anchos de banda y estrategias de contradicción para revelar propiedades de conectividad y optimización en redes."
413,PrioriKruskal,"Este ejercicio desafía a demostrar cómo la asignación de prioridades a las aristas, además de sus pesos, en los algoritmos de Kruskal y Prim, garantiza la obtención de un árbol generador mínimo específico, y cómo la unicidad de los pesos en un grafo conduce a un único árbol generador mínimo."
414,DualKruskal,"El desafío consiste en demostrar que un grafo tiene un único árbol generador mínimo si el algoritmo de Kruskal, aplicado con una función de prioridad y su inverso negativo, produce el mismo árbol, enfatizando el análisis de la invarianza del árbol generador mínimo ante dichas condiciones."
415,ConectaUnos,"El desafío consiste en diseñar un algoritmo que conecte todas las posiciones con valor 1 en una matriz cuadrada, evitando las casillas con valor 2, con el objetivo de minimizar la longitud total de los caminos. Se busca una solución con una complejidad temporal de $O(kn^2)$, donde $k$ es la cantidad de unos en la matriz."
416,CactoGrafos,"Este ejercicio desafía a demostrar propiedades únicas de los grafos cactus, diseñar algoritmos eficientes para identificar y analizar su estructura, y explorar la generación de árboles mínimos dentro de estos grafos especiales, todo esto con la restricción de mantener una complejidad temporal óptima."
417,TopoSortDFS,"Analiza y prueba si un digrafo es acíclico implementando un algoritmo DFS para generar un orden topológico, modificando el enfoque para obviar la necesidad de un vértice universalmente alcanzable."
418,Unicamino,"Diseñar una estructura de datos que, tras procesar un grafo $G$ en tiempo $O(n+m)$, permita determinar en tiempo constante $O(1)$ si existe un único camino entre dos vértices dados."
419,Bosques Seguros,"Este ejercicio desafía a demostrar que un meta-algoritmo específico siempre genera un árbol generador mínimo para un grafo pesado, aplicando inducción y luego compararlo con los algoritmos de Prim y Kruskal. Además, invita a explorar una implementación eficiente del algoritmo de Borůvka, precursor en la construcción de árboles generadores mínimos."
501,Rutas Óptimas y Alternativas,Este ejercicio desafía a demostrar la eficiencia de una arista en un camino mínimo entre dos vértices en un digrafo ponderado y a desarrollar un algoritmo que identifique el camino mínimo alternativo que evite aristas consideradas óptimas. Se centra en la comprensión profunda de caminos mínimos y la innovación en la búsqueda de alternativas eficientes.
502,OptiRutas,"Diseñar un algoritmo para identificar qué aristas, no presentes inicialmente en un digrafo ponderado, reducen el costo del camino más corto entre dos vértices dados al ser añadidas. Debe demostrarse la corrección del algoritmo propuesto."
503,Ruta SemiNegativa,"Diseña un algoritmo para encontrar el camino mínimo en un digrafo pesado de un vértice inicial a un destino, permitiendo el uso de máximo una arista de peso negativo. Demuestra su corrección."
504,OptiRutas,"Diseña un algoritmo para identificar qué aristas agregadas a un digrafo ponderado mejoran la distancia entre dos vértices dados, asegurando la eficiencia y demostrando su corrección."
505,Aristas Críticas,"Diseñar un algoritmo que identifique las aristas críticas en un digrafo ponderado con vértices especiales $s$ y $t$, donde una arista es crítica si su eliminación aumenta la distancia mínima entre $s$ y $t$. El ejercicio desafía a demostrar la corrección del algoritmo y sugiere enfocarse en el grafo de caminos mínimos."
506,CaminosProbabilísticos,"El desafío consiste en modelar y encontrar el camino de peso multiplicativo mínimo en un digrafo, donde los pesos representan probabilidades, transformando este problema en uno de camino mínimo mediante el uso de logaritmos para convertir multiplicaciones en sumas, y demostrar la corrección del algoritmo propuesto."
507,CicloPuré,"El desafío consiste en modelar y resolver el problema de prevenir el ""negocio del ciclo puré"" en una ciudad con cabinas de peaje regulares, inversas y mixtas, analizando la viabilidad de ciclos de tráfico que generan ganancias infinitas. Se busca diseñar un algoritmo eficiente que determine la presencia de estos ciclos bajo distintas configuraciones de cabinas, teniendo en cuenta los costos de tránsito y peaje."
508,Desafío SRD,"Este ejercicio desafía a demostrar propiedades fundamentales de los sistemas de restricciones de diferencias y su representación como digrafos pesados, culminando en el diseño de un algoritmo para determinar la solubilidad del sistema y, en caso de ser insoluble, identificar las inecuaciones conflictivas."
509,Paréntesis Espaciados,"El desafío consiste en determinar si es posible distribuir un conjunto de paréntesis que abren y cierran en una cadena, de tal manera que cada par esté separado por una longitud impar específica, generando así una secuencia válida. Se busca definir un Sistema de Restricciones Diádicas (SRD) para resolver este problema de forma eficiente, con restricciones que permitan una solución en tiempo cuadrático respecto al número de paréntesis."
510,CajasAmistad,"El objetivo es asignar a cada cliente de un supermercado una caja para hacer fila, garantizando que amigos estén lo suficientemente cerca y aquellos que se pelean estén adecuadamente separados, mediante un sistema de restricciones de diferencias y un algoritmo polinomial. Este desafío combina la lógica de asignación espacial con las dinámicas de relaciones interpersonales, respetando las distancias mínimas y máximas impuestas por amistades y conflictos."
511,CajasEnfrentadas,"Este ejercicio desafía a asignar clientes a cajas de un supermercado dispuestas circularmente, asegurando que aquellos que se han peleado estén separados por al menos un número específico de pasillos, teniendo en cuenta una valla que impide el paso directo entre la caja M y la 1. El objetivo es modelar el problema con restricciones de diferencias, desarrollar un algoritmo polinomial para resolverlo y analizar su complejidad en función de las peleas ocurridas."
512,MateCiclo,"Este ejercicio desafía a modelar y resolver el problema de determinar las cantidades exactas de edulcorante (ICPC) a agregar en rondas de mate para satisfacer las preferencias de dulzura de un grupo de amigos, utilizando un sistema representado por un grafo cíclico y desarrollando un algoritmo eficiente de tiempo lineal \(O(n)\)."
513,MatrizFW,"Desarrolla un algoritmo capaz de determinar si una matriz cuadrada, simétrica y positiva puede ser el resultado de aplicar el algoritmo de Floyd-Warshall a un grafo, y en caso afirmativo, reconstruye el grafo con el menor número de aristas posible."
514,AristaMaxST,"Encuentra la arista en un digrafo ponderado sin ciclos de peso negativo que maximiza su eficiencia st, es decir, que es st-eficiente para el mayor número de pares s y t. Diseña un algoritmo simple y eficiente para lograrlo, aplicando propiedades específicas de eficiencia en grafos."
515,GeoVerificador,"Diseña e implementa un algoritmo de complejidad O(n^3) que, dado un grafo pesado y conexo, determina si un conjunto de vértices especificado cubre todos los caminos mínimos entre pares de vértices, comprobando su cualidad geodésica."
516,CaminoMinDAG,"El ejercicio se centra en diseñar funciones y algoritmos para encontrar el camino de peso mínimo en un digrafo acíclico y conexo, destacando enfoques de programación dinámica tanto top-down como bottom-up. La particularidad radica en el uso de una función de pesos y la ausencia de ciclos dirigidos, siendo clave un orden topológico para el método bottom-up."
517,VueltoÓptimo,"Este ejercicio desafía al estudiante a modelar el problema de encontrar el vuelto mínimo utilizando diferentes denominaciones de monedas como un problema de camino mínimo, y resolverlo mediante un algoritmo eficiente con complejidad $O(vk)$. Se invita a explorar la conexión con la programación dinámica."
518,CaminoCrítico,"El desafío consiste en identificar todas las etapas críticas en la gestión de un proyecto, modelando el problema como un caso de camino mínimo y utilizando un algoritmo de tiempo lineal para su resolución. Se enfoca en la dependencia temporal entre etapas y la identificación de puntos susceptibles a causar retrasos."
519,RutasOptimizadas,"Este ejercicio desafía a seleccionar el algoritmo más eficiente para encontrar caminos mínimos en grafos, considerando diferentes condiciones como densidad, igualdad de pesos y signo de los mismos. Se abordan variadas situaciones desde caminos individuales hasta la conectividad completa y la detección de ciclos negativos."
520,ViajeroTemporal,"Diseña algoritmos eficientes para calcular el tiempo mínimo de llegada a diferentes locaciones en un digrafo con tiempos de viaje y de apertura específicos, adaptando los algoritmos de Dijkstra y de Bellman-Ford para manejar peculiaridades temporales, incluyendo aristas que ""retroceden en el tiempo""."
601,ParidadFlujoMax,"Este ejercicio desafía a demostrar o refutar afirmaciones relacionadas con la paridad y racionalidad del flujo máximo en redes, basándose en las capacidades de sus aristas. Se explora cómo las propiedades numéricas de las capacidades afectan al flujo máximo."
602,Desafío Ford-Fulkerson,"Construye una red específica de 4 vértices y 5 aristas que desafíe el algoritmo de Ford y Fulkerson, requiriendo $F$ iteraciones para alcanzar el flujo máximo desde un flujo inicial nulo, explorando así la eficiencia del algoritmo en condiciones extremas."
603,FlujoMáx-EdKarp,"Analiza la complejidad del algoritmo de Edmonds y Karp para determinar el flujo máximo en redes bajo tres escenarios distintos: sin conocimiento de capacidades, con capacidades máximas reducidas y con un flujo máximo significativamente menor que el producto de vértices y aristas."
604,CorteCapMín,"Diseñar un algoritmo eficiente que, dada una red de flujo y un flujo máximo predefinido, identifique el corte de menor capacidad posible. Este reto pone a prueba la habilidad para optimizar la búsqueda de soluciones en contextos de redes de flujo."
605,FlujosDisjuntos,"Este ejercicio desafía a modelar la búsqueda de la máxima cantidad de caminos disjuntos en aristas entre dos vértices específicos de un digrafo, utilizando conceptos de flujo, y a analizar la complejidad de resolver este modelo con el algoritmo de Edmonds y Karp. Se enfoca en la aplicación de teoría de flujos y análisis de complejidad algorítmica."
606,FiestaSolteres,"Desarrollar un algoritmo que modele y resuelva la asignación óptima de personas solteras a mesas en las fiestas de casamiento de Asignasonia, respetando las peculiares limitaciones familiares y de capacidad de mesas, utilizando un modelo de flujo y analizando su complejidad con el algoritmo de Edmonds y Karp."
607,FlujoMatricial,"Este ejercicio desafía a modelar la asignación de valores en una matriz, asegurando sumas específicas por filas y columnas, como un problema de flujo. El reto incluye interpretar unidades de flujo, demostrar la validez del modelo y analizar su complejidad con el algoritmo de Edmonds y Karp."
608,DigraFlujo,"Este ejercicio desafía a modelar la tarea de encontrar un digrafo que cumpla con una secuencia digráfica específica como un problema de flujo, aplicando análisis y algoritmos de flujo para validar la solución y determinar su complejidad computacional."
609,FlujoEuleriano,"Este ejercicio desafía a modelar la determinación de si un grafo mixto es euleriano utilizando conceptos de flujo de red, interpretar unidades de flujo y restricciones, demostrar la validez del modelo propuesto, y finalmente analizar la complejidad de resolverlo mediante el algoritmo de Edmonds y Karp. La clave está en la creatividad para aplicar teoría de flujos a un problema clásico de grafos."
610,AdaptaFlujo,"Este desafío consiste en modelar un problema de flujo en redes para minimizar el número de dispositivos electrónicos sin energía en una cumbre internacional, utilizando adaptadores limitados y encadenables. Se aborda la aplicación de un modelo matemático específico y el análisis de su complejidad computacional mediante el algoritmo de Edmonds y Karp."
611,Figuritas90,"En este desafío, el objetivo es maximizar la colección de figuritas únicas de Carle mediante el diseño de un modelo de flujo máximo, aprovechando el intercambio estratégico con compañeros bajo el protocolo ""late-nola"" y considerando repeticiones y preferencias específicas. Se requiere analizar la eficiencia del algoritmo de Edmonds y Karp aplicado al modelo propuesto."
612,FlujoCostoOptimo,"El ejercicio desafía a demostrar que el algoritmo de Ford y Fulkerson, al seleccionar caminos de aumento de costo mínimo, resuelve eficientemente el problema de flujo máximo con costo mínimo en una red, y requiere determinar un algoritmo para la elección de estos caminos y analizar su complejidad computacional."
613,MatchMínPeso,"Este ejercicio desafía a transformar el problema de encontrar el matching de máximo tamaño y mínimo peso en un grafo bipartito en un problema de flujo máximo de costo mínimo, analizando la interpretación de flujos y costos y demostrando la validez del modelo propuesto."
614,TSP Bimodal,"Este ejercicio desafía a encontrar el ciclo de costo mínimo en un digrafo completo que respeta un orden preestablecido para los nodos pares, mediante la modelación del problema como un matching bipartito de peso mínimo. Se explora la representación, corrección del modelo y su complejidad computacional."
615,FlujoFactible,"Este ejercicio se centra en demostrar la existencia de un flujo factible en una red con demandas transformándola en una red sin demandas, mediante la adición de nodos y ajustes en las capacidades. El desafío reside en establecer un vínculo entre el flujo máximo de la red transformada y la satisfacción de las demandas originales."
